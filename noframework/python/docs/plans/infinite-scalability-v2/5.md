# Task 5: Tree-sitter Parser Setup

## Objective
Set up tree-sitter parsing infrastructure for supported languages.

## Dependencies
- Task 4: read_file tool (basic)

## Deliverables

`tech_writer/parser.py`:

```python
from tree_sitter_languages import get_parser, get_language

SUPPORTED_LANGUAGES = {
    "python", "javascript", "typescript", "tsx",
    "go", "rust", "java", "c", "cpp"
}

def parse_file(content: str, lang: str) -> Tree | None:
    """
    Parse file content into AST.

    Returns None if language not supported.
    """

def is_supported(lang: str) -> bool:
    """Check if language has tree-sitter support."""

def get_node_text(node: Node, content: str) -> str:
    """Extract text for an AST node."""
```

## Acceptance Criteria

- [ ] Parses Python files into AST
- [ ] Parses JavaScript/TypeScript files into AST
- [ ] Returns None gracefully for unsupported languages
- [ ] Handles malformed code (partial parse)
- [ ] `get_node_text` extracts correct text spans

## Test Cases

```gherkin
Feature: Tree-sitter parsing

  Scenario: Parse Python file
    Given Python code "def foo():\n    pass"
    When I parse it as "python"
    Then I should get a valid AST
    And the root node type should be "module"

  Scenario: Parse JavaScript file
    Given JavaScript code "function foo() { return 1; }"
    When I parse it as "javascript"
    Then I should get a valid AST
    And the root node type should be "program"

  Scenario: Unsupported language
    Given some text content
    When I parse it as "unknown"
    Then I should get None

  Scenario: Malformed code
    Given Python code "def foo(\n    # incomplete"
    When I parse it as "python"
    Then I should get a partial AST
    And the AST should have error nodes
```

## Implementation Notes

- Use `tree-sitter-languages` package (already in project)
- Cache parsers per language (they're reusable)
- Tree-sitter handles malformed code gracefully with error recovery
