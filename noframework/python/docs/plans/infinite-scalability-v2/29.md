# Task 29: Feature: Citation Verification

## Objective
BDD tests for citation parsing and verification.

## Dependencies
- Task 28: Feature: section generation

## Deliverables

`tests/features/citations.feature`:

```gherkin
Feature: Citation verification
  As a tech writer system
  I need to verify citations
  So that documentation is accurate and traceable

  # Parsing tests

  Scenario: Parse valid citation
    Given citation string "src/main.py:10-25"
    When I parse the citation
    Then path should be "src/main.py"
    And start_line should be 10
    And end_line should be 25

  Scenario: Parse nested path
    Given citation string "lib/core/Axios.js:100-150"
    When I parse the citation
    Then path should be "lib/core/Axios.js"

  Scenario: Parse single line citation
    Given citation string "main.py:5-5"
    When I parse the citation
    Then start_line should equal end_line

  Scenario: Invalid citation format - missing end
    Given citation string "main.py:10"
    When I try to parse the citation
    Then a ValueError should be raised

  Scenario: Invalid citation format - non-numeric
    Given citation string "main.py:abc-def"
    When I try to parse the citation
    Then a ValueError should be raised

  # Extraction tests

  Scenario: Extract citations from markdown
    Given markdown content:
      """
      The main class [lib/axios.js:10-20] provides
      HTTP methods [lib/axios.js:30-40] for requests.
      """
    When I extract citations
    Then I should find 2 citations

  Scenario: Extract citations from complex markdown
    Given markdown content with code blocks and lists
    When I extract citations
    Then citations should be found in all contexts

  # Verification tests

  Scenario: Verify valid citation
    Given file "src/main.py" is cached with 100 lines
    When I verify citation "src/main.py:10-20"
    Then the citation should be valid
    And I should get the cited content

  Scenario: Verify citation - file not cached
    Given file "unknown.py" is NOT in cache
    When I verify citation "unknown.py:10-20"
    Then the citation should be invalid
    And error should mention "not found"

  Scenario: Verify citation - line out of bounds
    Given file "src/main.py" is cached with 50 lines
    When I verify citation "src/main.py:40-60"
    Then the citation should be invalid
    And error should mention "out of range"

  Scenario: Verify all citations in document
    Given a document with 5 citations
    And 3 citations are valid and 2 are invalid
    When I verify all citations
    Then valid_count should be 3
    And invalid_count should be 2
    And I should get details for invalid ones
```

## Step Definitions

`tests/step_defs/citation_steps.py`:

```python
from pytest_bdd import given, when, then, parsers
from tech_writer.citations import (
    parse_citation, extract_citations,
    verify_citation, verify_all_citations
)

@given(parsers.parse('citation string "{citation}"'))
def set_citation_string(citation, context):
    context["citation_str"] = citation

@when("I parse the citation")
def parse_citation_step(context):
    context["citation"] = parse_citation(context["citation_str"])

@when("I try to parse the citation")
def try_parse_citation(context):
    try:
        context["citation"] = parse_citation(context["citation_str"])
        context["error"] = None
    except ValueError as e:
        context["error"] = e

@then(parsers.parse('path should be "{expected}"'))
def check_path(expected, context):
    assert context["citation"].path == expected

@then(parsers.parse("start_line should be {expected:d}"))
def check_start_line(expected, context):
    assert context["citation"].start_line == expected

@then("a ValueError should be raised")
def check_value_error(context):
    assert context["error"] is not None
    assert isinstance(context["error"], ValueError)

@given(parsers.parse('file "{path}" is cached with {lines:d} lines'))
def cache_file_with_lines(path, lines, store):
    content = "\n".join([f"line {i}" for i in range(1, lines + 1)])
    store.add_file(path, content, "python")

@given(parsers.parse('file "{path}" is NOT in cache'))
def ensure_not_cached(path, store):
    # Just don't add it - store starts empty
    pass

@when(parsers.parse('I verify citation "{citation}"'))
def verify_citation_step(citation, store, context):
    from tech_writer.citations import Citation
    cit = parse_citation(citation)
    context["result"] = verify_citation(cit, store)

@then("the citation should be valid")
def check_valid(context):
    assert context["result"].valid is True

@then("the citation should be invalid")
def check_invalid(context):
    assert context["result"].valid is False
```

## Test Matrix

| Scenario | Input | Expected |
|----------|-------|----------|
| Valid parse | "a.py:1-10" | Citation(path="a.py", start=1, end=10) |
| Nested path | "a/b/c.py:1-10" | path="a/b/c.py" |
| Invalid format | "a.py:10" | ValueError |
| Extract multiple | "...[a:1-2]...[b:3-4]..." | 2 citations |
| Verify valid | cached file, valid range | valid=True |
| Verify no file | uncached file | valid=False, error |
| Verify OOB | cached 50 lines, 40-60 | valid=False, error |

## Implementation Notes

- Test parsing independently from verification
- Use in-memory store for fast tests
- Test both happy paths and error cases
- Verify error messages are helpful
