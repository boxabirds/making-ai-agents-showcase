# Task 33: Implement FTS5 in CacheStore

## Objective
Replace the `NotImplementedError` in `CacheStore.search()` with a proper SQLite FTS5 implementation.

## Dependencies
- Task 2: SQLite cache store (base implementation)

## Problem Statement

Task 13 was marked complete, but `store.py:276-278` still has:
```python
def search(self, query: str, limit: int = 20) -> list[dict]:
    """Full-text search across cached files."""
    raise NotImplementedError("Task 13")
```

The `search_text` tool in `semantic.py` works around this with regex matching, but this is O(n) instead of O(log n).

## Deliverables

### 1. Add FTS5 schema to `store.py`

```python
FTS_SCHEMA = """
CREATE VIRTUAL TABLE IF NOT EXISTS files_fts USING fts5(
    path,
    content,
    content='files',
    content_rowid='id'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS files_ai AFTER INSERT ON files BEGIN
    INSERT INTO files_fts(rowid, path, content) VALUES (new.id, new.path, new.content);
END;

CREATE TRIGGER IF NOT EXISTS files_ad AFTER DELETE ON files BEGIN
    INSERT INTO files_fts(files_fts, rowid, path, content) VALUES('delete', old.id, old.path, old.content);
END;

CREATE TRIGGER IF NOT EXISTS files_au AFTER UPDATE ON files BEGIN
    INSERT INTO files_fts(files_fts, rowid, path, content) VALUES('delete', old.id, old.path, old.content);
    INSERT INTO files_fts(rowid, path, content) VALUES (new.id, new.path, new.content);
END;
"""
```

### 2. Implement `search()` method

```python
def search(self, query: str, limit: int = 20) -> list[dict]:
    """
    Full-text search across cached files using FTS5.

    Args:
        query: Search string (supports FTS5 query syntax)
        limit: Maximum results to return

    Returns:
        List of matches: [{"path": str, "line": int, "snippet": str, "score": float}, ...]
    """
    # Escape special FTS5 characters for literal search
    escaped_query = self._escape_fts_query(query)

    cursor = self._conn.execute(
        """
        SELECT
            f.path,
            f.content,
            bm25(files_fts) as score
        FROM files_fts
        JOIN files f ON files_fts.rowid = f.id
        WHERE files_fts MATCH ?
        ORDER BY score
        LIMIT ?
        """,
        (escaped_query, limit)
    )

    results = []
    for row in cursor.fetchall():
        # Find matching lines within the file
        path = row["path"]
        content = row["content"]
        score = row["score"]

        for line_num, line in enumerate(content.splitlines(), start=1):
            if query.lower() in line.lower():
                results.append({
                    "path": path,
                    "line": line_num,
                    "snippet": line.strip(),
                    "score": score,
                })
                if len(results) >= limit:
                    break

        if len(results) >= limit:
            break

    return results

def _escape_fts_query(self, query: str) -> str:
    """Escape special FTS5 characters for literal search."""
    # FTS5 special chars: AND OR NOT ( ) " *
    # Wrap in quotes for phrase search
    escaped = query.replace('"', '""')
    return f'"{escaped}"'
```

### 3. Update `_init_schema()` to include FTS

```python
def _init_schema(self) -> None:
    """Initialize database schema including FTS."""
    self._conn.executescript(SCHEMA)
    self._conn.executescript(FTS_SCHEMA)
    self._conn.commit()
```

### 4. Update `search_text` in `semantic.py` to use FTS

```python
def search_text(
    query: str,
    store: CacheStore,
    limit: int = 20,
) -> list[dict]:
    """
    Full-text search across cached files.

    Uses SQLite FTS5 for efficient search.

    Args:
        query: Search string
        store: Cache store with FTS index
        limit: Maximum results

    Returns:
        [{"path": str, "line": int, "snippet": str, "score": float}, ...]
    """
    return store.search(query, limit=limit)
```

## Acceptance Criteria

- [ ] `CacheStore.search()` returns results instead of raising `NotImplementedError`
- [ ] FTS5 virtual table is created on store initialization
- [ ] Triggers keep FTS index in sync with files table
- [ ] Search returns path, line number, snippet, and relevance score
- [ ] Special characters in query are escaped properly
- [ ] Results are sorted by relevance (BM25)
- [ ] Limit parameter is respected
- [ ] Empty query returns empty list (not error)

## Test Cases

```gherkin
Feature: FTS5 search

  Scenario: Basic search
    Given I have cached files containing "authenticate"
    When I call store.search("authenticate")
    Then I should get matches with path and line numbers
    And snippets should contain "authenticate"

  Scenario: Search with special characters
    Given I have cached files containing "user.name"
    When I call store.search("user.name")
    Then the search should not fail
    And I should get matches

  Scenario: Search respects limit
    Given I have cached 100 files containing "import"
    When I call store.search("import", limit=5)
    Then I should get at most 5 results

  Scenario: FTS stays in sync
    Given I have cached a file with "original"
    When I update the file to contain "modified"
    And I call store.search("original")
    Then I should get no results
    And store.search("modified") should return the file

  Scenario: Phrase search
    Given I have cached files containing "hello world"
    When I call store.search("hello world")
    Then I should match files with that exact phrase

  Scenario: Search empty cache
    Given an empty store
    When I call store.search("anything")
    Then I should get an empty list
```

## Implementation Notes

- SQLite FTS5 is built into Python's sqlite3 module
- Use content-external table to avoid storing content twice
- Triggers automatically index new/updated/deleted files
- BM25 scoring provides relevance ranking
- Escape user queries to prevent FTS5 syntax errors
- Line-level matching happens post-FTS for precise results
- Consider adding `file_pattern` filter as optional enhancement
