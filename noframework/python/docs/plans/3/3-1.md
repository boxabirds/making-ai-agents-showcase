# Task 3-1: Create complexity.py module

## Reference

See `docs/designs/3/tech-design.md` Â§Python Integration

## Requirements

Create `tech_writer/complexity.py` with:

1. **Constants**
   - `BUCKET_SIMPLE_MAX = 5_000`
   - `BUCKET_MEDIUM_MAX = 25_000`
   - `BUCKET_LARGE_MAX = 100_000`
   - Budget configs per bucket (max_sections, max_exploration, section_max_steps)

2. **Dataclass: `ComplexityBudget`**
   - `total_cc: int`
   - `bucket: str`
   - `max_sections: int`
   - `max_exploration_steps: int`
   - `section_max_steps: int`
   - `guidance: str`
   - `top_functions: list[dict]`

3. **Function: `get_analyzer_path() -> Optional[Path]`**
   - Check if `complexity-analyzer` is in PATH
   - Check relative path for development setup
   - Return None if not found

4. **Function: `analyze_complexity(repo_path: Path) -> Optional[dict]`**
   - Run complexity analyzer subprocess
   - Parse JSON output
   - Return None on error/timeout

5. **Function: `map_complexity_to_budget(analysis: dict) -> ComplexityBudget`**
   - Map Total CC to bucket
   - Return appropriate budget config

6. **Function: `get_complexity_context(budget: ComplexityBudget) -> str`**
   - Generate LLM context string with bucket, guidance, hotspots

## Testing Approach

Tests created in task 3-2.

## Acceptance Criteria

- [ ] All functions importable from `tech_writer.complexity`
- [ ] Constants match Rust implementation thresholds
- [ ] Graceful None return when analyzer unavailable
