# Task 3-7: Implement build-on-demand and Python fallback

## Reference

See `docs/designs/3/tech-design.md` Â§Binary Distribution Options

## Requirements

1. **Build-on-demand function**
   ```python
   def ensure_analyzer_built() -> Optional[Path]:
       """Build analyzer if cargo available and binary missing."""
       binary = Path("tools/complexity-analyzer/target/release/complexity-analyzer")
       if binary.exists():
           return binary

       # Check cargo available
       if shutil.which("cargo") is None:
           return None

       # Build
       result = subprocess.run(
           ["cargo", "build", "--release"],
           cwd="tools/complexity-analyzer",
           capture_output=True,
       )
       if result.returncode == 0:
           return binary
       return None
   ```

2. **Python fallback**
   - If Rust analyzer unavailable, use Python implementation
   - Import from `pocs.code_base_complexity.complexity_analyzer`
   - Log performance warning

3. **Fallback order**
   1. Rust binary in PATH
   2. Rust binary in `tools/complexity-analyzer/`
   3. Build Rust binary (if cargo available)
   4. Python fallback
   5. Return None (use defaults)

## Testing Approach

- Mock subprocess calls
- Test fallback chain

## Acceptance Criteria

- [ ] Build-on-demand works when cargo available
- [ ] Python fallback used when Rust unavailable
- [ ] Warning logged when using fallback
- [ ] Graceful degradation to defaults
