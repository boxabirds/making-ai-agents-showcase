# Infinite-Scalability Design Audit (2025-11-22 18:50)

## Findings vs design
- Ingestion skips unsupported languages entirely and only emits self-loop import edges for Python, leaving large coverage and graph gaps; see `infinite_scalability/ingest.py:118-125` and `infinite_scalability/ingest.py:179-203`.
- Summarization stops at file/module, attaches a single first-chunk citation, and uses a placeholder module target id; no chunk or package summaries or validation are run (`infinite_scalability/summarize.py:10-76`, `infinite_scalability/validation.py` unused in the pipeline).
- Retrieval is mostly lexical FTS on chunks plus a full table scan over summaries, with stub embeddings and minimal graph leverage (`infinite_scalability/retrieval.py:16-161`).
- Citation enforcement drops lines without citations instead of repairing them, so prompt sections can vanish before verification (`infinite_scalability/enforcement.py:9-32`).
- Claim checking relies on substring-matching an LLM response, and the gating loop never revises drafts or fills citation_score; issues are planned but ignored (`infinite_scalability/claims.py:73-141`, `infinite_scalability/orchestrator.py:56-96`).
- Coverage modeling is limited to symbol-name string matches, ignoring endpoints/config/build items and skipped files; coverage can read as 1.0 even when large areas are unprocessed (`infinite_scalability/coverage.py:21-48` plus ingestion skip behavior above).
- Schema omits the summary FTS and indexing the design calls for (edges/symbols/claims/summaries have no indexes or FKs to targets), which will hurt retrieval and referential integrity (`infinite_scalability/schema.py:19-125`).
- Evaluation computes support/coverage/citation directly from stored claim statuses instead of rechecking against source chunks, so it cannot detect stale or incorrect claims (`infinite_scalability/eval.py:9-45`).

## Recommended tasks
1) Ingest/graph completeness: add fallback chunking or explicit skip records for unsupported languages; extract real symbols and edges (calls/imports/inheritance/member-of) across languages instead of self-loops; persist skipped files into coverage surfaces.
2) Summarization stack: implement chunk -> file -> module -> package summaries with citations carried upward; store real module/package identifiers; run `validate_summary` before persisting.
3) Retrieval fidelity: add FTS5 on summaries, integrate symbol/edge expansion in scoring, and replace hash-based embeddings with optional real vectors that are always re-ranked by lexical/graph signals.
4) Drafting/citations: repair missing citations using retrieved chunks rather than dropping lines; enforce that drafts only use citations present in the evidence set while preserving prompt-requested sections.
5) Claim checking and iteration: switch to structured claim grading tied to cited chunks, compute citation_score/support_rate explicitly, and introduce a ReviseReport step that uses planned issues to regenerate drafts until gates pass.
6) Coverage modeling: derive expected surfaces from symbols plus endpoints/routes/config/build targets; track skipped/uncovered files and feed them into gating instead of string-contains heuristics.
7) Schema/index hardening: add indexes on symbols (name, kind, file), edges (src/dst/edge_type), claims (report_version), and summaries (target_id, level); add FTS on summaries.text; add FKs from summaries.target_id to files/modules/packages and from embeddings to symbols.
8) Evaluations/tests: enhance eval_runner to rerun retrieval/claim checks against stored chunks for metrics; add regression/property/golden tests for the iteration loop, citation enforcement, retrieval reranking, and coverage gate behaviors.

## Task backlog
- [ ] Ingestion/graph: add fallback chunking or explicit skip records for unsupported languages; extract real symbol edges (calls/imports/inheritance/member-of) instead of Python self-loops; persist skipped files into coverage targets.
- [ ] Summaries: implement chunk-level summaries and package-level aggregation; store real module/package identifiers; run `validate_summary` before inserts; carry citations upward rather than picking the first.
- [ ] Retrieval: add FTS5 on summaries.text; fold symbols/edges into scoring; replace hash embeddings with optional real vectors re-ranked by lexical/graph signals.
- [ ] Drafting/citations: repair missing citations by retrieving chunks instead of dropping lines; ensure drafts only use evidence citations while preserving prompt-requested sections.
- [ ] Claim checking/iteration: grade claims with structured outputs tied to cited chunks; compute citation_score/support_rate explicitly; add ReviseReport using planned issues; loop until gates pass or max iters.
- [ ] Coverage: derive expected surfaces from symbols plus endpoints/routes/config/build items; include skipped/unparsed files; reject string-contains-only coverage.
- [ ] Schema/indexes: add indexes on symbols (name, kind, file_id), edges (src_symbol_id, dst_symbol_id, edge_type), summaries (target_id, level), claims (report_version); add FTS on summaries; add FKs for summaries.target_id and embeddings to symbols.
- [ ] Evaluation/tests: extend eval_runner to re-run retrieval/claim checks against stored chunks; add regression/property/golden tests for iteration loop, citation enforcement, retrieval reranking, and coverage gate behavior.
