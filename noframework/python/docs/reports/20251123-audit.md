# Tech Writer v2 Implementation Audit

**Date:** 2025-11-23
**Auditor:** Claude Sonnet 4.5
**Design Spec:** `docs/design/infinite-scalability-v2.md`
**Verdict:** ~~Implementation is ~85% complete. Critical gaps exist in agentic section generation and CLI controls.~~

**UPDATE:** All gaps have been addressed. See Tasks 31-35 in `docs/plans/infinite-scalability-v2/tasks.md`.

---

## Executive Summary

The v2 implementation successfully delivers on the core design promises:
- **Agentic exploration** with semantic tree-sitter powered tools
- **Lazy caching** - only caches what the LLM reads
- **Section-by-section output** with citation requirements
- **Citation verification** system

However, several design features are incomplete or missing entirely, and one task (Task 13: FTS) is marked complete but contains `NotImplementedError`.

---

## Gap Analysis

### GAP-1: Section Generation is NOT Agentic (High Severity)

**Design spec (Phase 3, lines 49-56):**
> Section generation is itself agentic:
> - LLM can do more exploration if needed
> - Generate section content with citations

**Implementation (`orchestrator.py:283-337`):**
```python
def generate(self, section, prompt, previous_sections):
    # ... builds context ...
    response = self.llm_client.chat(messages)  # Single chat call, no tool loop
    return response["content"] or ""
```

The `SectionGenerator.generate()` method makes a single LLM chat call with pre-gathered context. The LLM cannot call `read_file` or semantic tools during section generation.

**Impact:** When the pre-gathered context (first 100 lines per file) is insufficient, the LLM cannot explore further. This breaks the design's promise of arbitrary-depth exploration per section.

**Fix:** Replace `llm_client.chat()` with `llm_client.run_tool_loop()` and provide tool handlers, similar to `explore_codebase()`.

---

### GAP-2: CLI Missing Design-Specified Flags (Medium Severity)

**Design spec (lines 376-391):**
```bash
# Control exploration depth
python -m tech_writer --prompt prompt.md --repo /path/to/repo --max-exploration 30

# Control output sections
python -m tech_writer --prompt prompt.md --repo /path/to/repo --max-sections 20

# Persist cache for debugging
python -m tech_writer --prompt prompt.md --repo /path/to/repo --persist-cache
```

**Implementation (`cli.py`):**
- `--max-exploration`: **Missing** (hardcoded to 50 in `explore_codebase`)
- `--max-sections`: **Missing** (no limit on outline sections)
- `--persist-cache`: **Missing** (uses in-memory DB by default, `--cache-dir` only affects cloned repos)

**Impact:** Users cannot control exploration depth or cache persistence for debugging. No way to limit runaway exploration costs.

---

### GAP-3: FTS5 Marked Complete but Not Implemented (Medium Severity)

**`tasks.md` line 22:**
```
| 13 | search_text tool (FTS) | ✅ done | 2 |
```

**`store.py:276-278`:**
```python
def search(self, query: str, limit: int = 20) -> list[dict]:
    """Full-text search across cached files."""
    raise NotImplementedError("Task 13")
```

The task is marked done, but `CacheStore.search()` throws `NotImplementedError`. The `search_text` tool in `semantic.py` works around this with simple regex matching on cached content, but this is not FTS5.

**Design spec (lines 322-327):**
> SQLite caches what was read during the run:
> - FTS index on cached content (for text search fallback)

**Impact:** Text search is O(n) regex over cached files rather than O(log n) FTS. Acceptable for small caches, poor for large explorations.

---

### GAP-4: No Citation Re-generation for Invalid Citations (Medium Severity)

**Design spec (Phase 4, lines 306-309):**
> If invalid citations exist:
> - Flag them in the output
> - Re-generate affected sections with stricter instructions
> - Or accept best-effort output

**Implementation (`cli.py:77-90`):**
```python
if args.verify_citations:
    results, valid, invalid = verify_all_citations(report, store)
    # ... prints report to stderr ...
    # No re-generation logic
```

The CLI flags invalid citations but never attempts re-generation. The design explicitly calls for re-generating affected sections.

**Impact:** Invalid citations remain in the output. User must manually identify and fix them.

---

### GAP-5: No Integration/E2E Tests (Low Severity)

**Design spec (lines 395-398):**
> Testing Strategy:
> 4. Integration tests: End-to-end on small fixture repos

**`tasks.md` line 39:**
```
| 30 | E2E: axios + architecture-overview-lite | ✅ done | 29, 23 |
```

**Implementation:** No E2E test files exist. The tests in `test_core.py` are unit tests with mock fixtures. There is no test that runs the full pipeline against a real or fixture repository.

**Impact:** No automated verification that the full pipeline works. Regression risk.

---

### GAP-6: `run_pipeline` Missing Configurable Parameters (Low Severity)

**Implementation (`orchestrator.py:97-104`):**
```python
def run_pipeline(
    prompt: str,
    repo: str,
    cache_dir: Optional[str] = None,
    model: str = "gpt-4o",
    api_key: Optional[str] = None,
    base_url: Optional[str] = None,
) -> tuple[str, CacheStore]:
```

Missing parameters from design:
- `max_exploration_steps`: Exists in `explore_codebase()` (default 50) but not exposed
- `max_sections`: No limit enforcement
- `persist_cache`: No option to save DB to disk

---

## What Works Well

| Component | Status | Notes |
|-----------|--------|-------|
| Tree-sitter parser | ✅ Complete | 15 languages supported |
| All 9 semantic tools | ✅ Complete | `list_files`, `read_file`, `get_symbols`, `get_imports`, `get_definition`, `get_references`, `get_structure`, `search_text`, `finish_exploration` |
| Agentic exploration (Phase 1) | ✅ Complete | Tool loop with proper message handling |
| Outline generation (Phase 2) | ✅ Complete | JSON parsing with graceful fallback |
| Citation parsing & verification | ✅ Complete | Format: `[path:start-end]` |
| Report assembly | ✅ Complete | Combines sections with title extraction |
| Remote repo support | ✅ Complete | Shallow clone with caching |
| Lazy file caching | ✅ Complete | Only caches what LLM reads |
| Unit test coverage | ✅ Good | 42+ tests covering tools, parser, citations |

---

## Proposed Tasks

### P0 (Critical)

| Task | Description | Effort |
|------|-------------|--------|
| **Make section generation agentic** | Replace `chat()` with `run_tool_loop()` in `SectionGenerator.generate()`. Provide tool handlers. | Medium |

### P1 (High)

| Task | Description | Effort |
|------|-------------|--------|
| **Add `--max-exploration` CLI flag** | Wire to `explore_codebase(max_steps=N)` | Small |
| **Add `--max-sections` CLI flag** | Truncate outline after N sections | Small |
| **Add `--persist-cache` CLI flag** | Allow saving SQLite DB to disk | Small |
| **Implement FTS5 in CacheStore** | Create FTS5 virtual table, implement `search()` method | Medium |

### P2 (Medium)

| Task | Description | Effort |
|------|-------------|--------|
| **Implement citation re-generation** | When invalid citations found, re-run `SectionGenerator` for affected sections with stricter prompt | Medium |
| **Add E2E integration test** | Test full pipeline against fixture repo (not axios - too large for CI) | Medium |
| **Expose all pipeline parameters** | Add `max_exploration`, `max_sections`, `db_path` to `run_pipeline()` | Small |

### P3 (Low)

| Task | Description | Effort |
|------|-------------|--------|
| **Fix Task 13 status** | Either complete FTS5 or mark task as incomplete | Trivial |
| **Add pipeline metrics** | Track LLM calls, tokens used, cache hits | Small |

---

## Conclusion

The v2 implementation is a solid foundation that correctly inverts the v1 architecture: lazy caching, query-driven exploration, and section-by-section generation. The agentic exploration loop works correctly.

The critical gap is that **section generation is not agentic as designed**. The LLM cannot explore further during section writing, which undermines the "arbitrary-length, citation-backed reports" goal. Fixing this is the highest priority.

The CLI control gaps (`--max-exploration`, `--max-sections`, `--persist-cache`) are straightforward additions that would bring the implementation in line with the design spec.

---

## Appendix: Code Location Reference

| Component | File | Key Lines |
|-----------|------|-----------|
| Pipeline orchestration | `orchestrator.py` | 97-155 |
| Agentic exploration | `orchestrator.py` | 158-202 |
| Section generation (non-agentic) | `orchestrator.py` | 268-337 |
| CLI implementation | `cli.py` | 13-112 |
| FTS NotImplementedError | `store.py` | 276-278 |
| Citation verification | `citations.py` | 58-95 |
| Tree-sitter parser | `parser.py` | 1-748 |
| Semantic tools | `tools/semantic.py` | 1-236 |
