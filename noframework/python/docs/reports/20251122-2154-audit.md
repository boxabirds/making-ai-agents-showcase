# Infinite-Scalability Design Audit (2025-11-22 21:54)

## Findings vs design
- **Source of truth & ingest gaps**: Unsupported languages are logged and skipped entirely, so raw text/chunks are missing (`infinite_scalability/ingest.py:147-155`). YAML/TOML are forced into paragraph chunking even though tree-sitter support exists (`ingest.py:131-154`), and the graph only links symbol names without package/qualifier context or parent/uses edges. Deterministic 8-d hash embeddings are written for every chunk without an option to disable or plug real vectors (`ingest.py:162-190`), and symbol embeddings are never produced.
- **Summaries diverge from navigation-only role**: File summaries ignore chunk summaries and attach a single first-chunk citation (`summarize.py:12-40`); module/package reducers simply concatenate child text with optional child citations, not a DSPy reduce with validation (`summarize.py:90-154`). These summaries are then injected as evidence for drafting, turning non-source summaries into ground truth (`orchestrator.py:33-34`), contrary to the design’s “summaries for navigation only” rule. No sampling/validator loop exists to check summary fidelity.
- **Retrieval underuses graph/embeddings**: Context is mostly FTS over chunks with light boosts; edges are only used to append a single chunk per endpoint (`retrieval.py:123-186`). There is no traversal/radius control, no symbol regex/exact lookup beyond `LIKE`, and embeddings require the caller to supply a query vector with a full table scan (`retrieval.py:80-120`) rather than a hybrid lexical+graph rerank. Module/package summaries are not searchable by structure (no join to modules/packages).
- **Drafting & citation handling brittle**: Evidence is limited to the initial retrieval set and summaries; later iterations never refresh evidence (`orchestrator.py:25-118`). `enforce_draft_citations` can slap on the first allowed citation even if unrelated, or fall back to the first chunk in the store (`enforcement.py:27-50,54-74`), so content is not actually repaired—only citations are. Allowed citations are derived from evidence tokens, so if drafting invents new sections, enforcement may inject arbitrary citations instead of retrieving matching chunks (`orchestrator.py:41-52`).
- **Claims/verification not schema-driven**: Claim extraction is a line heuristic without Pydantic output contracts or section awareness (`claims.py:24-46`). Claim checking validates at most one cited chunk and then jumps to retrieval to find any chunk that grades as “supported,” overwriting citations with newly invented ones (`claims.py:105-150`), so claims are not tied to the report’s cited evidence as required. There is no structured ClaimCheckResult with severities/contradictions surfaced to the gate.
- **Iteration & gating incomplete**: The loop never re-runs ingest/summarize/retrieve, so revisions can’t fix coverage gaps by adding evidence (`orchestrator.py:66-124`). Issues are computed but not persisted, and support/citation rates aren’t stored in `report_versions` (only coverage/issue counts are written) (`orchestrator.py:77-89`). `gate_should_continue` only checks missing_citations==0 plus rates, ignoring issue list severity ordering and max iterations rationale output (`coverage.py:101-118`). No IterationStatus/Issue tracking per design.
- **Coverage surface too naive**: Expected targets are just file paths plus bare symbol names and a few heuristics for config/build (`coverage.py:22-40`). There’s no endpoint/route/build-target discovery, no treatment of unparsed/skipped files beyond a file target, and string-contains matching can mark unrelated claims as covered (`coverage.py:43-68`). Coverage isn’t recalculated against a scope/module surface, and skipped languages never get chunk targets, so coverage may overreport.
- **Schema integrity holes**: `summaries.target_id` has no foreign key to files/modules/packages, and modules/packages are never linked back to files, so summaries can reference nonexistent targets (`schema.py:72-88`). Edges lack a primary key and uniqueness, and summary/package/module constraints from the design are absent. Store lifecycle allows reusing a persisted `--store-path`, violating the “DBs are never reused across runs” rule (`cli.py:20-63`).
- **Evaluation/metrics not measuring truth**: `evaluate_metrics` force-marks every citation as supported via a dummy grader and divides by a caller-supplied expected_items count (often file count), so it cannot detect contradictions or stale claims (`eval.py:11-57`). It doesn’t re-run retrieval/claim checking against stored chunks or recompute coverage/citation gates per design.
- **LLM/DSPy contracts & validation**: LLM outputs for drafting and claim grading are free-form strings; there’s no Pydantic validation/retry loop for tool/LLM IO beyond `SummaryOutput` inside `summarize_text` (`llm.py:22-66`, `claims.py:67-83`). DSPy modules are thin wrappers without compilation or policy tuning, and tool contracts (ToolListFiles, ToolGetChunks, etc.) are unused. No logging of retrieval sets, issue lists, or rationales is persisted to the store.
- **Testing gaps vs design**: Tests cover smoke ingestion/retrieval/summarize but skip multi-language parsing, graph edges, summary validation sampling, hybrid retrieval rerank, citation enforcement repair vs drop, iteration gate behavior across retries, persisted store auditing, and eval_runner rechecking. There are no property/golden/regression tests called for in the design (`tests/`).

## Recommended follow-ups
1) Ingest/graph: store raw chunks for all files (even unsupported) or add tree-sitter grammars; stop paragraph-only chunking where parsers exist; emit qualified symbol identities and richer edges (calls/imports/implements/uses/member-of) with parent links and symbol embeddings.
2) Summaries: build file summaries from chunk summaries, run a reduce LLM for module/package with citation propagation, and keep summaries strictly for navigation (exclude from evidence); add validation/sampling hooks and confidence-based drill-down.
3) Retrieval: implement hybrid rerank (lexical + graph + optional embeddings) with graph expansion radius and symbol/module-aware queries; index/join summaries with modules/packages; add ANN or efficient on-disk vector search with lexical post-filtering.
4) Drafting/citations: regenerate evidence per iteration, repair missing citations by retrieving matching chunks instead of placeholder tokens, and enforce that report citations are a subset of the evidence set tied to stored chunks.
5) Claims/iteration: introduce structured claim extraction/check schemas, keep citations aligned to the drafted report, surface contradictions/uncertainty with severities, persist iteration status/issue lists, and re-run retrieve/check/revise until gates pass or fail with rationale.
6) Coverage: derive expected surfaces from symbols/endpoints/routes/config/build artifacts and unparsed files, avoid string-contains matching, and compute coverage per module/scope with citation-backed hits only.
7) Schema/store: add FKs for summaries.target_id to files/modules/packages, module→package/file linkage, edge uniqueness, and lifecycle guards to prevent store reuse; expose stored retrieval sets/issues for audit.
8) Evaluation/tests: enhance eval_runner to re-run retrieval and claim checking against stored chunks/summaries/symbols; add regression/property/golden tests for iteration loop, citation enforcement, retrieval reranking, coverage gates, and persisted-store auditing.***
