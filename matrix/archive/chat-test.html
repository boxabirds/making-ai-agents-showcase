<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Writer Agent Implementation Comparison - Powered by Gemini</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f5f5f5;
            line-height: 1.6;
        }

        /* Demo page styles */
        .demo-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .demo-content h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .demo-content p {
            color: #666;
            margin-bottom: 15px;
        }

        /* Chat Widget Styles */
        .chat-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        /* Chat Bubble Button */
        .chat-bubble {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .chat-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.3);
        }

        .chat-bubble svg {
            width: 30px;
            height: 30px;
            fill: white;
        }

        /* Notification Badge */
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff4757;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Chat Window */
        .chat-window {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 380px;
            height: 600px;
            min-width: 300px;
            min-height: 400px;
            max-width: 90vw;
            max-height: 90vh;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: none;
            flex-direction: column;
            overflow: hidden;
            animation: slideUp 0.3s ease;
            resize: both;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .chat-window.active {
            display: flex;
        }

        /* Chat Header */
        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: move;
            user-select: none;
        }

        .chat-header h3 {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .chat-header p {
            font-size: 12px;
            opacity: 0.9;
            margin: 4px 0 0 0;
        }

        .close-button {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.3s;
        }

        .close-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Messages Area */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #f9f9f9;
        }

        .message {
            display: flex;
            gap: 10px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message-content {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 15px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background-color: #667eea;
            color: white;
            border-bottom-right-radius: 5px;
        }

        .message.assistant .message-content {
            background-color: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 5px;
        }

        /* Avatar */
        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .message.user .avatar {
            background-color: #e0e0e0;
            color: #666;
            order: 1;
        }

        .message.assistant .avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: none;
            padding: 20px;
            justify-content: flex-start;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-bubble {
            background-color: white;
            border: 1px solid #e0e0e0;
            padding: 12px 20px;
            border-radius: 15px;
            border-bottom-left-radius: 5px;
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: #666;
            border-radius: 50%;
            animation: typing 1.4s ease-in-out infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.5;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        /* Input Area */
        .input-container {
            padding: 20px;
            background-color: white;
            border-top: 1px solid #e0e0e0;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #e0e0e0;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .chat-input:focus {
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .send-button svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Welcome Message */
        .welcome-message {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .welcome-message h4 {
            color: #333;
            margin-bottom: 10px;
        }

        .quick-questions {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .quick-question {
            background-color: white;
            border: 1px solid #e0e0e0;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 13px;
            color: #667eea;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quick-question:hover {
            background-color: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.3);
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, #667eea 50%);
            border-bottom-right-radius: 15px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .resize-handle:hover {
            opacity: 0.8;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .chat-window {
                width: 100%;
                height: 100%;
                right: 0;
                bottom: 0;
                border-radius: 0;
                resize: none;
            }

            .chat-bubble {
                bottom: 10px;
                right: 10px;
            }
            
            .resize-handle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Demo Page Content -->
    <div class="demo-content">
        <h1>Tech Writer Agent Implementation Comparison</h1>
        <p>Compare different Python packages for building AI-powered documentation agents.</p>
        <p>This demo showcases a chatbot powered by Google's Gemini AI that can help you choose the best package for your needs.</p>
        
        <h2>Available Implementations:</h2>
        <ul>
            <li><strong>Baremetal</strong> - Custom ReAct implementation from scratch</li>
            <li><strong>DSPy</strong> - Declarative signature-based approach</li>
            <li><strong>Atomic Agents</strong> - Type-safe enterprise patterns</li>
            <li><strong>Agno</strong> - Minimalist implementation</li>
            <li><strong>LangGraph</strong> - Graph-based async workflows</li>
            <li><strong>Pydantic-AI</strong> - Clean patterns with dependency injection</li>
            <li><strong>Autogen</strong> - Microsoft's conversational agent framework</li>
            <li><strong>ADK-Python</strong> - Streamlined agent development kit</li>
        </ul>
        
        <h2>Try asking:</h2>
        <ul>
            <li>"What's the simplest implementation?"</li>
            <li>"I need type safety - what should I use?"</li>
            <li>"Compare DSPy and Pydantic-AI"</li>
            <li>"Which framework has the best async support?"</li>
        </ul>
    </div>

    <!-- Chat Widget -->
    <div class="chat-widget">
        <!-- Chat Bubble -->
        <div class="chat-bubble" id="chatBubble">
            <span class="notification-badge">1</span>
            <svg viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12c0 1.54.36 3 .97 4.29L1 23l6.71-1.97C9 21.64 10.46 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm0 18c-1.41 0-2.73-.36-3.88-.99l-.28-.15-2.94.85.85-2.94-.15-.28C4.36 14.73 4 13.41 4 12c0-4.41 3.59-8 8-8s8 3.59 8 8-3.59 8-8 8z"/>
            </svg>
        </div>

        <!-- Chat Window -->
        <div class="chat-window" id="chatWindow">
            <div class="chat-header">
                <div>
                    <h3>Tech Writer Agent Assistant</h3>
                    <p>Powered by Gemini AI</p>
                </div>
                <button class="close-button" id="closeButton">×</button>
            </div>

            <div class="messages-container" id="messagesContainer">
                <div class="welcome-message">
                    <h4>Welcome! 👋</h4>
                    <p>I can help you choose the best Python package for your AI-powered documentation needs.</p>
                    <div class="quick-questions">
                        <div class="quick-question" onclick="window.chatWidget.sendQuickQuestion('What\'s the simplest implementation available?')">
                            What's the simplest implementation?
                        </div>
                        <div class="quick-question" onclick="window.chatWidget.sendQuickQuestion('Which framework offers the best type safety?')">
                            Which has the best type safety?
                        </div>
                        <div class="quick-question" onclick="window.chatWidget.sendQuickQuestion('Compare LangGraph and Pydantic-AI')">
                            Compare LangGraph vs Pydantic-AI
                        </div>
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-bubble">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        class="chat-input" 
                        id="chatInput" 
                        placeholder="Ask about tech writer implementations..."
                        autocomplete="off"
                    >
                    <button class="send-button" id="sendButton">
                        <svg viewBox="0 0 24 24">
                            <path d="M2 21l21-9L2 3v7l15 2-15 2v7z"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="resize-handle" id="resizeHandle"></div>
        </div>
    </div>

    <script>
        // System prompt with complete tech writer comparison data and tone profile
        const systemPrompt = `You are a tech writer agent support agent. You host an app that helps a user compare implementations of a tech writer agent using various different open source python packages. You respond to the questions in a tone of voice profile as defined below, in response to the tech writer agent data provided, also below. Regarding answer content, as a chatbot your answers are incredibly accurate, concise and to the point.

<tech-writer-comparison>
${JSON.stringify({
  "comparisons": [
    {
      "vendor_a": "baremetal",
      "vendor_b": "atomic-agents",
      "summary": "Baremetal implements a custom ReAct agent from scratch with 315 lines of detailed control flow, while Atomic Agents leverages a framework with Pydantic schemas and structured components in 234 lines. Baremetal offers complete control but requires more boilerplate, whereas Atomic Agents provides type safety and better separation of concerns.",
      "suitability": {
        "baremetal": "Better for educational purposes, custom agent behaviors, or when you need fine-grained control over the ReAct loop",
        "atomic-agents": "Better for production systems requiring type safety, schema validation, and standardized agent patterns"
      },
      "overall_winner": "atomic-agents for most use cases due to better maintainability and type safety",
      "pros_cons": {
        "baremetal": {
          "pros": ["Complete control over agent behavior", "No framework dependencies", "Educational value", "Direct API integration"],
          "cons": ["More code to maintain", "Manual error handling", "No type safety", "Reinventing the wheel"]
        },
        "atomic-agents": {
          "pros": ["Type-safe with Pydantic", "Structured tool definitions", "Framework handles boilerplate", "Better separation of concerns"],
          "cons": ["Framework learning curve", "More dependencies", "Less flexibility for custom behaviors", "Heavier setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Agent class definition",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [154, 196], "component": "TechWriterAgent class"},
          "comparison": "Baremetal's 248-line class implements full ReAct logic manually, while Atomic's 42-line class leverages framework abstractions"
        },
        {
          "description": "Tool definition approach",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions method"},
          "vendor_b": {"lines": [53, 123], "component": "Tool schema classes"},
          "comparison": "Baremetal uses introspection to create OpenAI tool definitions (87 lines), Atomic uses Pydantic schemas (70 lines) for type-safe tools"
        },
        {
          "description": "LLM client initialization",
          "vendor_a": {"lines": [26, 49], "component": "__init__ with vendor detection"},
          "vendor_b": {"lines": [158, 159], "component": "instructor.from_litellm"},
          "comparison": "Baremetal manually handles vendor detection in 23 lines, Atomic delegates to LiteLLM in 2 lines"
        },
        {
          "description": "Agent execution loop",
          "vendor_a": {"lines": [226, 273], "component": "run method with ReAct loop"},
          "vendor_b": {"lines": [192, 194], "component": "agent.run call"},
          "comparison": "Baremetal implements full ReAct loop in 47 lines, Atomic delegates to framework in 3 lines"
        },
        {
          "description": "Tool execution",
          "vendor_a": {"lines": [192, 223], "component": "execute_tool method"},
          "vendor_b": {"lines": [77, 92], "component": "Tool run methods"},
          "comparison": "Baremetal has centralized tool execution (31 lines), Atomic has per-tool run methods (15 lines each)"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "dspy",
      "summary": "Baremetal's 315-line implementation provides complete control over the ReAct pattern, while DSPy achieves the same functionality in just 119 lines using its declarative signature-based approach. DSPy's conciseness comes from abstracting away the agent loop entirely.",
      "suitability": {
        "baremetal": "When you need to understand or customize ReAct implementation details",
        "dspy": "When you want the simplest possible implementation with minimal code"
      },
      "overall_winner": "dspy for simplicity and maintainability",
      "pros_cons": {
        "baremetal": {
          "pros": ["Full visibility into ReAct logic", "Customizable behavior", "No DSPy learning curve"],
          "cons": ["10x more code", "Manual implementation of standard patterns", "More potential for bugs"]
        },
        "dspy": {
          "pros": ["Extremely concise", "Declarative approach", "Built-in ReAct", "Automatic optimization potential"],
          "cons": ["Black box ReAct implementation", "DSPy-specific patterns", "Less control"]
        }
      },
      "block_mappings": [
        {
          "description": "Entire agent implementation",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [40, 81], "component": "TechWriterSignature class"},
          "comparison": "Baremetal's 248-line class vs DSPy's 41-line signature - DSPy achieves same result with 83% less code"
        },
        {
          "description": "ReAct pattern implementation",
          "vendor_a": {"lines": [226, 273], "component": "run method"},
          "vendor_b": {"lines": [91, 93], "component": "dspy.ReAct instantiation"},
          "comparison": "Baremetal implements ReAct loop in 47 lines, DSPy uses built-in ReAct in 3 lines"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [93, 93], "component": "tools=TOOLS parameter"},
          "comparison": "Baremetal converts tools in 87 lines, DSPy passes tools directly in 1 line"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "agno",
      "summary": "Baremetal's 315 lines of explicit ReAct implementation contrasts sharply with Agno's 104-line minimalist approach. Agno achieves brevity by delegating all agent logic to the underlying LLM provider.",
      "suitability": {
        "baremetal": "When you need to understand exactly how ReAct works",
        "agno": "When you want the absolute minimum code to get an agent running"
      },
      "overall_winner": "agno for rapid prototyping, baremetal for learning",
      "pros_cons": {
        "baremetal": {
          "pros": ["Educational value", "Complete control", "Transparent logic", "Customizable"],
          "cons": ["3x more code", "Maintenance burden", "Reinventing patterns"]
        },
        "agno": {
          "pros": ["Minimal code", "Quick to implement", "Easy to read", "Low complexity"],
          "cons": ["No control over agent behavior", "Limited customization", "Opaque execution"]
        }
      },
      "block_mappings": [
        {
          "description": "Main execution logic",
          "vendor_a": {"lines": [280, 313], "component": "main function"},
          "vendor_b": {"lines": [66, 102], "component": "main function"},
          "comparison": "Baremetal's 33-line main vs Agno's 36-line main - similar size but Agno includes all logic here"
        },
        {
          "description": "Agent implementation",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [59, 64], "component": "Agent instantiation"},
          "comparison": "Baremetal implements 248-line agent class, Agno uses 5-line instantiation"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "langgraph",
      "summary": "Baremetal's 315-line custom implementation versus LangGraph's 166-line async-first approach shows different philosophies. LangGraph provides graph-based workflow capabilities in half the code.",
      "suitability": {
        "baremetal": "When you need educational clarity or custom behavior",
        "langgraph": "When you need async support and want to leverage LangChain ecosystem"
      },
      "overall_winner": "langgraph for modern async applications",
      "pros_cons": {
        "baremetal": {
          "pros": ["No framework dependencies", "Clear logic flow", "Complete control"],
          "cons": ["No async support", "More code", "Manual state management"]
        },
        "langgraph": {
          "pros": ["Native async", "Graph workflows", "LangChain integration", "Streaming support"],
          "cons": ["Framework lock-in", "Learning curve", "More complex setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Async vs sync execution",
          "vendor_a": {"lines": [280, 313], "component": "sync main"},
          "vendor_b": {"lines": [102, 131], "component": "async main"},
          "comparison": "Baremetal uses synchronous execution, LangGraph is async-native with streaming"
        },
        {
          "description": "State management",
          "vendor_a": {"lines": [25, 49], "component": "Instance variables"},
          "vendor_b": {"lines": [33, 59], "component": "AgentState TypedDict"},
          "comparison": "Baremetal uses class instance state, LangGraph uses typed state dictionary"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "pydantic-ai",
      "summary": "Baremetal's 315-line explicit implementation versus Pydantic-AI's 136-line framework approach showcases traditional OOP versus modern dependency injection patterns.",
      "suitability": {
        "baremetal": "When you need to see every step of the ReAct process",
        "pydantic-ai": "When you want clean, testable code with minimal boilerplate"
      },
      "overall_winner": "pydantic-ai for clean architecture",
      "pros_cons": {
        "baremetal": {
          "pros": ["Transparent logic", "No framework magic", "Educational"],
          "cons": ["2.3x more code", "Manual patterns", "Less testable"]
        },
        "pydantic-ai": {
          "pros": ["Dependency injection", "Clean patterns", "Testable", "Type-safe"],
          "cons": ["Framework conventions", "Hidden complexity", "Beta software"]
        }
      },
      "block_mappings": [
        {
          "description": "Dependency management",
          "vendor_a": {"lines": [26, 49], "component": "Constructor with hardcoded deps"},
          "vendor_b": {"lines": [25, 35], "component": "Context class with DI"},
          "comparison": "Baremetal hardcodes dependencies, Pydantic-AI uses clean dependency injection"
        },
        {
          "description": "Tool registration",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [37, 66], "component": "@tech_writer.tool decorators"},
          "comparison": "Baremetal's 87-line tool conversion vs Pydantic-AI's decorator pattern"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "autogen",
      "summary": "Baremetal's 315 lines of custom code versus AutoGen's 210 lines shows Microsoft's framework provides similar control with 33% less code through intelligent abstractions.",
      "suitability": {
        "baremetal": "When you need to customize every aspect of agent behavior",
        "autogen": "When you want production-ready agents with Microsoft's backing"
      },
      "overall_winner": "autogen for production use cases",
      "pros_cons": {
        "baremetal": {
          "pros": ["No dependencies on Microsoft stack", "Complete customization", "Simpler mental model"],
          "cons": ["More code", "Less features", "Manual orchestration"]
        },
        "autogen": {
          "pros": ["Microsoft support", "Multi-agent capable", "Built-in patterns", "Active development"],
          "cons": ["Heavier framework", "Microsoft conventions", "More complex API"]
        }
      },
      "block_mappings": [
        {
          "description": "Agent creation pattern",
          "vendor_a": {"lines": [25, 273], "component": "Custom agent class"},
          "vendor_b": {"lines": [82, 126], "component": "AssistantAgent configuration"},
          "comparison": "Baremetal's 248-line class vs AutoGen's 44-line configuration approach"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [192, 223], "component": "execute_tool method"},
          "vendor_b": {"lines": [82, 126], "component": "tools parameter"},
          "comparison": "Baremetal manually executes tools, AutoGen handles it declaratively"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "adk-python",
      "summary": "Baremetal's 315-line ground-up implementation versus ADK's 151-line streamlined approach shows how a focused SDK can reduce code by 52% while maintaining clarity.",
      "suitability": {
        "baremetal": "When you need to understand ReAct internals",
        "adk-python": "When you want a balanced approach with less code"
      },
      "overall_winner": "adk-python for most use cases",
      "pros_cons": {
        "baremetal": {
          "pros": ["No SDK dependencies", "Full visibility", "Complete control"],
          "cons": ["2x more code", "More bugs possible", "Higher maintenance"]
        },
        "adk-python": {
          "pros": ["Cleaner code", "Good abstractions", "Balanced approach", "Less boilerplate"],
          "cons": ["SDK dependency", "Less customization", "Newer/less proven"]
        }
      },
      "block_mappings": [
        {
          "description": "Configuration approach",
          "vendor_a": {"lines": [26, 49], "component": "Manual setup in __init__"},
          "vendor_b": {"lines": [41, 66], "component": "Config dictionary"},
          "comparison": "Baremetal uses constructor parameters, ADK uses configuration dictionary"
        },
        {
          "description": "Response handling",
          "vendor_a": {"lines": [145, 190], "component": "stream_response method"},
          "vendor_b": {"lines": [96, 120], "component": "Direct message handling"},
          "comparison": "Baremetal's 45-line streaming vs ADK's 24-line message approach"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "dspy",
      "summary": "Atomic Agents' 234-line type-safe implementation versus DSPy's 119-line declarative approach represents the classic trade-off between explicit structure and concise expression.",
      "suitability": {
        "atomic-agents": "When type safety and enterprise patterns are critical",
        "dspy": "When rapid development and minimal code are priorities"
      },
      "overall_winner": "dspy for simplicity, atomic-agents for enterprise",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Full type safety", "Clear structure", "Tool schemas", "Enterprise-ready"],
          "cons": ["2x more code", "More boilerplate", "Heavier setup"]
        },
        "dspy": {
          "pros": ["Half the code", "Declarative", "Quick to write", "Built-in optimizations"],
          "cons": ["Less type safety", "Black box behavior", "Different paradigm"]
        }
      },
      "block_mappings": [
        {
          "description": "Type definitions",
          "vendor_a": {"lines": [34, 123], "component": "Pydantic schemas"},
          "vendor_b": {"lines": [40, 50], "component": "DSPy signature"},
          "comparison": "Atomic's 89 lines of schemas vs DSPy's 10-line signature"
        },
        {
          "description": "Agent pattern",
          "vendor_a": {"lines": [154, 196], "component": "Agent class"},
          "vendor_b": {"lines": [91, 93], "component": "ReAct instantiation"},
          "comparison": "Atomic's 42-line class vs DSPy's 3-line ReAct setup"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "agno",
      "summary": "Atomic Agents' 234-line enterprise-grade implementation versus Agno's 104-line minimalist approach represents the extreme ends of the complexity spectrum in agent development.",
      "suitability": {
        "atomic-agents": "For production systems requiring type safety and maintainability",
        "agno": "For quick prototypes and simple use cases"
      },
      "overall_winner": "Context dependent - atomic-agents for production, agno for prototypes",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Type safety", "Structured patterns", "Tool validation", "Maintainable"],
          "cons": ["2.25x more code", "Steeper learning curve", "More setup required"]
        },
        "agno": {
          "pros": ["Minimal code", "Quick to start", "Easy to understand", "Low overhead"],
          "cons": ["No type checking", "Limited structure", "Less maintainable at scale"]
        }
      },
      "block_mappings": [
        {
          "description": "Schema definitions",
          "vendor_a": {"lines": [34, 123], "component": "Pydantic models"},
          "vendor_b": {"lines": [0, 0], "component": "No schemas"},
          "comparison": "Atomic has 89 lines of type definitions, Agno has none"
        },
        {
          "description": "Tool implementation",
          "vendor_a": {"lines": [66, 123], "component": "Tool classes"},
          "vendor_b": {"lines": [62, 62], "component": "tools parameter"},
          "comparison": "Atomic's structured tool classes vs Agno's simple parameter passing"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "langgraph",
      "summary": "Atomic Agents' 234-line sync implementation with type safety versus LangGraph's 166-line async graph-based approach shows different architectural priorities.",
      "suitability": {
        "atomic-agents": "When type safety and clear structure are paramount",
        "langgraph": "When you need async operations and graph workflows"
      },
      "overall_winner": "langgraph for modern async apps, atomic-agents for type safety",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Strong typing", "Clear patterns", "Explicit structure", "Good for teams"],
          "cons": ["No async support", "More verbose", "Heavier setup"]
        },
        "langgraph": {
          "pros": ["Native async", "Graph capabilities", "More concise", "Streaming"],
          "cons": ["Less type safety", "Graph complexity", "LangChain dependency"]
        }
      },
      "block_mappings": [
        {
          "description": "Async support",
          "vendor_a": {"lines": [154, 196], "component": "Sync agent class"},
          "vendor_b": {"lines": [102, 131], "component": "Async main function"},
          "comparison": "Atomic is sync-only, LangGraph is async-native"
        },
        {
          "description": "Type safety",
          "vendor_a": {"lines": [34, 123], "component": "Pydantic schemas"},
          "vendor_b": {"lines": [33, 59], "component": "TypedDict state"},
          "comparison": "Atomic uses full Pydantic validation, LangGraph uses basic TypedDict"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "pydantic-ai",
      "summary": "Both leverage Pydantic but differently: Atomic Agents uses it for tool schemas in 234 lines, while Pydantic-AI builds the entire agent pattern around it in 136 lines.",
      "suitability": {
        "atomic-agents": "When you need explicit control and clear boundaries",
        "pydantic-ai": "When you prefer framework conventions and DI patterns"
      },
      "overall_winner": "pydantic-ai for cleaner code, atomic-agents for explicitness",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Explicit patterns", "Clear tool boundaries", "Traditional OOP", "Proven approach"],
          "cons": ["More boilerplate", "Less elegant", "Manual wiring"]
        },
        "pydantic-ai": {
          "pros": ["Cleaner code", "DI patterns", "More concise", "Modern design"],
          "cons": ["Beta software", "Framework magic", "Hidden complexity"]
        }
      },
      "block_mappings": [
        {
          "description": "Dependency injection",
          "vendor_a": {"lines": [158, 159], "component": "Direct instantiation"},
          "vendor_b": {"lines": [25, 35], "component": "Context pattern"},
          "comparison": "Atomic uses direct instantiation, Pydantic-AI uses DI context"
        },
        {
          "description": "Code organization",
          "vendor_a": {"lines": [34, 123], "component": "Separate schema classes"},
          "vendor_b": {"lines": [37, 66], "component": "Inline tool methods"},
          "comparison": "Atomic separates schemas from logic, Pydantic-AI integrates them"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "autogen",
      "summary": "Atomic Agents' 234 lines of Pydantic-based structure versus AutoGen's 210 lines of Microsoft's framework show similar complexity with different design philosophies.",
      "suitability": {
        "atomic-agents": "When you prefer Pydantic patterns and type safety",
        "autogen": "When you want Microsoft's ecosystem and multi-agent support"
      },
      "overall_winner": "autogen for features, atomic-agents for type safety",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Pydantic validation", "Clear schemas", "Simpler mental model", "Type-safe throughout"],
          "cons": ["Single agent only", "Less features", "Manual orchestration"]
        },
        "autogen": {
          "pros": ["Multi-agent capable", "Microsoft backing", "More features", "Better async"],
          "cons": ["Less type safety", "More complex API", "Heavier framework"]
        }
      },
      "block_mappings": [
        {
          "description": "Framework philosophy",
          "vendor_a": {"lines": [34, 123], "component": "Schema-first design"},
          "vendor_b": {"lines": [42, 80], "component": "Function-first design"},
          "comparison": "Atomic starts with schemas, AutoGen starts with functions"
        },
        {
          "description": "Agent capabilities",
          "vendor_a": {"lines": [154, 196], "component": "Single agent"},
          "vendor_b": {"lines": [82, 126], "component": "AssistantAgent"},
          "comparison": "Atomic is single-agent, AutoGen supports multi-agent scenarios"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "adk-python",
      "summary": "Atomic Agents' 234-line type-safe implementation versus ADK's 151-line pragmatic approach shows how different abstraction levels affect code volume.",
      "suitability": {
        "atomic-agents": "When type safety and patterns are non-negotiable",
        "adk-python": "When you want good structure with less ceremony"
      },
      "overall_winner": "adk-python for balance, atomic-agents for safety",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Full type coverage", "Clear patterns", "Schema validation", "Enterprise-ready"],
          "cons": ["More verbose", "Heavier setup", "More concepts"]
        },
        "adk-python": {
          "pros": ["Less boilerplate", "Still structured", "Easier to start", "Good balance"],
          "cons": ["Less type safety", "Fewer guarantees", "Less mature"]
        }
      },
      "block_mappings": [
        {
          "description": "Type safety approach",
          "vendor_a": {"lines": [34, 123], "component": "Full Pydantic schemas"},
          "vendor_b": {"lines": [41, 66], "component": "Config dictionary"},
          "comparison": "Atomic has 89 lines of schemas, ADK uses dynamic config"
        },
        {
          "description": "Code overhead",
          "vendor_a": {"lines": [1, 234], "component": "Total implementation"},
          "vendor_b": {"lines": [1, 151], "component": "Total implementation"},
          "comparison": "Atomic has 55% more code due to type definitions and patterns"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "agno",
      "summary": "DSPy's 119-line declarative approach versus Agno's 104-line minimalist implementation shows two different philosophies for achieving simplicity.",
      "suitability": {
        "dspy": "When you want declarative patterns and potential optimizations",
        "agno": "When you want the absolute minimum viable agent"
      },
      "overall_winner": "dspy for its additional capabilities with minimal overhead",
      "pros_cons": {
        "dspy": {
          "pros": ["Declarative patterns", "Built-in ReAct", "Optimization potential", "Clean abstractions"],
          "cons": ["DSPy learning curve", "Framework-specific", "Less transparent"]
        },
        "agno": {
          "pros": ["Slightly less code", "No framework concepts", "Direct LLM usage", "Minimal dependencies"],
          "cons": ["Less structure", "No optimization", "Basic features only"]
        }
      },
      "block_mappings": [
        {
          "description": "Agent pattern",
          "vendor_a": {"lines": [40, 81], "component": "Signature + module"},
          "vendor_b": {"lines": [59, 64], "component": "Direct instantiation"},
          "comparison": "DSPy uses signatures and modules (41 lines), Agno uses direct Agent (5 lines)"
        },
        {
          "description": "Abstraction level",
          "vendor_a": {"lines": [91, 93], "component": "dspy.ReAct"},
          "vendor_b": {"lines": [88, 98], "component": "Direct prompt"},
          "comparison": "DSPy abstracts ReAct pattern, Agno uses direct prompting"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "langgraph",
      "summary": "DSPy's 119-line declarative sync approach versus LangGraph's 166-line graph-based async implementation shows different architectural choices for modern agents.",
      "suitability": {
        "dspy": "When you want simple, declarative agents with minimal code",
        "langgraph": "When you need async, streaming, and graph workflows"
      },
      "overall_winner": "langgraph for async apps, dspy for simplicity",
      "pros_cons": {
        "dspy": {
          "pros": ["More concise", "Declarative", "Built-in optimizations", "Simpler mental model"],
          "cons": ["No async", "Less control", "No streaming", "Limited to ReAct pattern"]
        },
        "langgraph": {
          "pros": ["Native async", "Graph workflows", "Streaming support", "More flexible"],
          "cons": ["More complex", "40% more code", "Steeper learning curve"]
        }
      },
      "block_mappings": [
        {
          "description": "Execution model",
          "vendor_a": {"lines": [110, 117], "component": "Sync execution"},
          "vendor_b": {"lines": [102, 131], "component": "Async execution"},
          "comparison": "DSPy is sync-only, LangGraph is async-native with streaming"
        },
        {
          "description": "Pattern abstraction",
          "vendor_a": {"lines": [91, 93], "component": "dspy.ReAct"},
          "vendor_b": {"lines": [98, 100], "component": "Graph compilation"},
          "comparison": "DSPy uses ReAct module, LangGraph uses graph compilation"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "pydantic-ai",
      "summary": "DSPy's 119-line declarative signatures versus Pydantic-AI's 136-line dependency injection approach represents two modern but different agent development philosophies.",
      "suitability": {
        "dspy": "When you want declarative simplicity and built-in patterns",
        "pydantic-ai": "When you need clean architecture and testability"
      },
      "overall_winner": "Both excel in different ways - choose based on priorities",
      "pros_cons": {
        "dspy": {
          "pros": ["More concise", "Built-in ReAct", "Potential optimizations", "Simpler setup"],
          "cons": ["Less testable", "Black box behavior", "DSPy-specific patterns"]
        },
        "pydantic-ai": {
          "pros": ["Dependency injection", "Better testability", "Clean patterns", "Type-safe"],
          "cons": ["Slightly more code", "Beta framework", "More concepts to learn"]
        }
      },
      "block_mappings": [
        {
          "description": "Design philosophy",
          "vendor_a": {"lines": [40, 81], "component": "Declarative signatures"},
          "vendor_b": {"lines": [25, 35], "component": "DI with context"},
          "comparison": "DSPy uses declarative signatures, Pydantic-AI uses dependency injection"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [93, 93], "component": "tools parameter"},
          "vendor_b": {"lines": [37, 66], "component": "Decorated methods"},
          "comparison": "DSPy passes tools directly, Pydantic-AI uses method decorators"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "autogen",
      "summary": "DSPy's 119-line declarative approach versus AutoGen's 210-line Microsoft framework shows the trade-off between simplicity and features.",
      "suitability": {
        "dspy": "When you want minimal code with powerful abstractions",
        "autogen": "When you need production features and multi-agent support"
      },
      "overall_winner": "autogen for production, dspy for simplicity",
      "pros_cons": {
        "dspy": {
          "pros": ["43% less code", "Cleaner abstractions", "Built-in patterns", "Easier to understand"],
          "cons": ["Single agent only", "Less production features", "Limited ecosystem"]
        },
        "autogen": {
          "pros": ["Multi-agent", "Production ready", "Microsoft support", "Rich features"],
          "cons": ["Nearly 2x code", "More complex", "Heavier framework"]
        }
      },
      "block_mappings": [
        {
          "description": "Framework scope",
          "vendor_a": {"lines": [1, 119], "component": "Entire implementation"},
          "vendor_b": {"lines": [1, 210], "component": "Entire implementation"},
          "comparison": "DSPy achieves similar single-agent functionality with 43% less code"
        },
        {
          "description": "Agent initialization",
          "vendor_a": {"lines": [91, 93], "component": "ReAct module"},
          "vendor_b": {"lines": [82, 126], "component": "AssistantAgent config"},
          "comparison": "DSPy's 3-line setup vs AutoGen's 44-line configuration"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "adk-python",
      "summary": "DSPy's 119-line declarative implementation versus ADK's 151-line traditional approach shows DSPy can be more concise even than lightweight SDKs.",
      "suitability": {
        "dspy": "When you want cutting-edge declarative patterns",
        "adk-python": "When you prefer traditional, straightforward code"
      },
      "overall_winner": "dspy for innovation, adk-python for familiarity",
      "pros_cons": {
        "dspy": {
          "pros": ["More concise", "Advanced patterns", "Built-in optimizations", "Cleaner abstractions"],
          "cons": ["New paradigm", "Less transparent", "DSPy dependency"]
        },
        "adk-python": {
          "pros": ["Traditional patterns", "More transparent", "Easier debugging", "Straightforward"],
          "cons": ["More boilerplate", "Less innovative", "Manual patterns"]
        }
      },
      "block_mappings": [
        {
          "description": "Implementation style",
          "vendor_a": {"lines": [40, 81], "component": "Signature + Module"},
          "vendor_b": {"lines": [72, 120], "component": "Traditional function"},
          "comparison": "DSPy uses signatures, ADK uses traditional agent functions"
        },
        {
          "description": "Code efficiency",
          "vendor_a": {"lines": [1, 119], "component": "Total lines"},
          "vendor_b": {"lines": [1, 151], "component": "Total lines"},
          "comparison": "DSPy achieves same result with 21% less code"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "langgraph",
      "summary": "Agno's 104-line bare minimum versus LangGraph's 166-line feature-rich async implementation shows the spectrum from simplest to full-featured.",
      "suitability": {
        "agno": "When you need something working in minutes",
        "langgraph": "When you need async, streaming, and advanced features"
      },
      "overall_winner": "langgraph for real applications, agno for quick prototypes",
      "pros_cons": {
        "agno": {
          "pros": ["Minimal code", "Quick setup", "Easy to understand", "Low complexity"],
          "cons": ["No async", "No streaming", "Basic features only", "Limited control"]
        },
        "langgraph": {
          "pros": ["Full async", "Streaming", "Graph workflows", "Production ready"],
          "cons": ["60% more code", "More complex", "Steeper learning curve"]
        }
      },
      "block_mappings": [
        {
          "description": "Feature set",
          "vendor_a": {"lines": [59, 102], "component": "Basic agent"},
          "vendor_b": {"lines": [33, 131], "component": "Full graph implementation"},
          "comparison": "Agno provides basics in 43 lines, LangGraph offers full features in 98 lines"
        },
        {
          "description": "Async support",
          "vendor_a": {"lines": [66, 102], "component": "Sync main"},
          "vendor_b": {"lines": [102, 131], "component": "Async main"},
          "comparison": "Agno is sync-only, LangGraph is async-native"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "pydantic-ai",
      "summary": "Agno's 104-line minimalist approach versus Pydantic-AI's 136-line pattern-based implementation shows different philosophies on the 'simple' end of the spectrum.",
      "suitability": {
        "agno": "When you want the absolute minimum code",
        "pydantic-ai": "When you want clean patterns without too much overhead"
      },
      "overall_winner": "pydantic-ai for its better patterns with minimal overhead",
      "pros_cons": {
        "agno": {
          "pros": ["Least code", "Fastest to implement", "No patterns to learn", "Direct"],
          "cons": ["No structure", "Hard to test", "Limited features", "Less maintainable"]
        },
        "pydantic-ai": {
          "pros": ["Clean patterns", "Testable", "DI support", "Type hints"],
          "cons": ["30% more code", "Beta framework", "More concepts"]
        }
      },
      "block_mappings": [
        {
          "description": "Structure",
          "vendor_a": {"lines": [1, 104], "component": "Flat script"},
          "vendor_b": {"lines": [25, 90], "component": "Structured classes"},
          "comparison": "Agno uses flat script structure, Pydantic-AI uses proper classes and DI"
        },
        {
          "description": "Testability",
          "vendor_a": {"lines": [66, 102], "component": "Monolithic main"},
          "vendor_b": {"lines": [25, 35], "component": "Injected dependencies"},
          "comparison": "Agno is hard to test, Pydantic-AI designed for testing"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "autogen",
      "summary": "Agno's 104-line minimal implementation versus AutoGen's 210-line enterprise framework represents the extremes of the agent development spectrum.",
      "suitability": {
        "agno": "For quick experiments and learning",
        "autogen": "For production systems requiring reliability and features"
      },
      "overall_winner": "autogen for any serious use case",
      "pros_cons": {
        "agno": {
          "pros": ["Half the code", "Quick to start", "Minimal dependencies", "Simple"],
          "cons": ["No production features", "Limited capabilities", "Poor maintainability"]
        },
        "autogen": {
          "pros": ["Production ready", "Multi-agent", "Microsoft support", "Full featured"],
          "cons": ["2x code", "Complex setup", "Learning curve", "Heavy framework"]
        }
      },
      "block_mappings": [
        {
          "description": "Production readiness",
          "vendor_a": {"lines": [1, 104], "component": "Basic script"},
          "vendor_b": {"lines": [1, 210], "component": "Full framework"},
          "comparison": "Agno is a simple script, AutoGen is a production framework"
        },
        {
          "description": "Agent capabilities",
          "vendor_a": {"lines": [59, 64], "component": "Basic agent"},
          "vendor_b": {"lines": [82, 126], "component": "AssistantAgent"},
          "comparison": "Agno's 5-line agent vs AutoGen's 44-line configurable agent"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "adk-python",
      "summary": "Agno's 104 lines versus ADK's 151 lines shows even 'simple' SDKs add 45% overhead compared to the most minimal approach.",
      "suitability": {
        "agno": "When every line of code counts",
        "adk-python": "When you want some structure without too much overhead"
      },
      "overall_winner": "adk-python for the better balance",
      "pros_cons": {
        "agno": {
          "pros": ["Absolute minimum", "No abstractions", "Quick to write", "Direct"],
          "cons": ["No structure", "Hard to extend", "Less readable", "Maintenance issues"]
        },
        "adk-python": {
          "pros": ["Better structure", "More maintainable", "Clear patterns", "Extensible"],
          "cons": ["45% more code", "Some boilerplate", "SDK dependency"]
        }
      },
      "block_mappings": [
        {
          "description": "Code organization",
          "vendor_a": {"lines": [1, 104], "component": "Single file"},
          "vendor_b": {"lines": [1, 151], "component": "Structured implementation"},
          "comparison": "Agno is minimal, ADK adds structure for 45% more code"
        },
        {
          "description": "Configuration",
          "vendor_a": {"lines": [59, 64], "component": "Inline config"},
          "vendor_b": {"lines": [41, 66], "component": "Config dictionary"},
          "comparison": "Agno uses inline params, ADK uses structured config"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "pydantic-ai",
      "summary": "Both modern async implementations take different approaches: LangGraph's 166 lines focus on graph-based workflows, while Pydantic-AI's 136 lines emphasize clean patterns with dependency injection.",
      "suitability": {
        "langgraph": "When you need LangChain ecosystem and graph workflows",
        "pydantic-ai": "When you want clean, testable code with DI patterns"
      },
      "overall_winner": "pydantic-ai for clean code, langgraph for ecosystem",
      "pros_cons": {
        "langgraph": {
          "pros": ["Rich ecosystem", "Graph workflows", "Streaming support", "LangChain integration"],
          "cons": ["More complex", "Heavier dependencies", "Verbose setup", "Framework lock-in"]
        },
        "pydantic-ai": {
          "pros": ["Cleaner patterns", "Dependency injection", "More concise", "Testable"],
          "cons": ["Less ecosystem", "No graph features", "Framework patterns", "Hidden control"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool definition style",
          "vendor_a": {"lines": [63, 96], "component": "Wrapper functions"},
          "vendor_b": {"lines": [37, 66], "component": "Decorated methods"},
          "comparison": "LangGraph's 33-line wrappers vs Pydantic-AI's 29-line decorators"
        },
        {
          "description": "Context handling",
          "vendor_a": {"lines": [74, 74], "component": "Closure binding"},
          "vendor_b": {"lines": [25, 29], "component": "Context class"},
          "comparison": "LangGraph uses closures vs Pydantic-AI's typed context"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [111, 118], "component": "agent.invoke"},
          "vendor_b": {"lines": [86, 90], "component": "tech_writer.run"},
          "comparison": "LangGraph's 7-line invoke vs Pydantic-AI's 4-line run"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "autogen",
      "summary": "LangGraph's 166-line graph-based async approach versus AutoGen's 210-line conversational framework shows two different visions for advanced agent development.",
      "suitability": {
        "langgraph": "When you need async graph workflows and streaming",
        "autogen": "When you need multi-agent conversations and Microsoft ecosystem"
      },
      "overall_winner": "langgraph for modern async apps, autogen for multi-agent scenarios",
      "pros_cons": {
        "langgraph": {
          "pros": ["Native async", "Graph workflows", "More concise", "Streaming support"],
          "cons": ["Single agent focus", "LangChain dependency", "Less mature"]
        },
        "autogen": {
          "pros": ["Multi-agent capable", "Microsoft backing", "More mature", "Richer features"],
          "cons": ["More verbose", "Heavier framework", "Complex API"]
        }
      },
      "block_mappings": [
        {
          "description": "Architecture pattern",
          "vendor_a": {"lines": [33, 59], "component": "Graph state"},
          "vendor_b": {"lines": [82, 126], "component": "Agent configuration"},
          "comparison": "LangGraph uses graph state pattern, AutoGen uses agent configuration"
        },
        {
          "description": "Async handling",
          "vendor_a": {"lines": [102, 131], "component": "Native async/await"},
          "vendor_b": {"lines": [192, 204], "component": "Async wrapped execution"},
          "comparison": "LangGraph is async-native, AutoGen wraps sync in async"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "adk-python",
      "summary": "LangGraph's 166-line graph-based implementation versus ADK's 151-line traditional approach shows similar complexity with very different architectures.",
      "suitability": {
        "langgraph": "When you need advanced async and graph capabilities",
        "adk-python": "When you want straightforward, traditional patterns"
      },
      "overall_winner": "langgraph for modern features, adk-python for simplicity",
      "pros_cons": {
        "langgraph": {
          "pros": ["Async native", "Graph workflows", "Advanced features", "Streaming"],
          "cons": ["More complex", "Steeper learning curve", "Framework specific"]
        },
        "adk-python": {
          "pros": ["Simpler patterns", "Easier to understand", "Traditional approach", "Less dependencies"],
          "cons": ["No async", "Basic features", "Less powerful"]
        }
      },
      "block_mappings": [
        {
          "description": "Architectural approach",
          "vendor_a": {"lines": [98, 100], "component": "Graph compilation"},
          "vendor_b": {"lines": [125, 134], "component": "Direct execution"},
          "comparison": "LangGraph compiles graphs, ADK uses direct execution"
        },
        {
          "description": "Complexity distribution",
          "vendor_a": {"lines": [33, 100], "component": "Setup and config"},
          "vendor_b": {"lines": [41, 66], "component": "Simple config"},
          "comparison": "LangGraph front-loads complexity in setup, ADK keeps it simple"
        }
      ]
    },
    {
      "vendor_a": "pydantic-ai",
      "vendor_b": "autogen",
      "summary": "Pydantic-AI's 136-line clean architecture versus AutoGen's 210-line comprehensive framework shows different approaches to production-ready agents.",
      "suitability": {
        "pydantic-ai": "When you want clean, testable code with minimal framework",
        "autogen": "When you need full features and multi-agent support"
      },
      "overall_winner": "autogen for features, pydantic-ai for clean code",
      "pros_cons": {
        "pydantic-ai": {
          "pros": ["Cleaner code", "Better testability", "DI patterns", "35% more concise"],
          "cons": ["Fewer features", "Beta status", "Single agent only", "Less ecosystem"]
        },
        "autogen": {
          "pros": ["More features", "Multi-agent", "Microsoft support", "Production proven"],
          "cons": ["More complex", "Heavier", "Less clean patterns", "More verbose"]
        }
      },
      "block_mappings": [
        {
          "description": "Design philosophy",
          "vendor_a": {"lines": [25, 35], "component": "DI with context"},
          "vendor_b": {"lines": [82, 126], "component": "Configuration-based"},
          "comparison": "Pydantic-AI uses DI patterns, AutoGen uses configuration"
        },
        {
          "description": "Code efficiency",
          "vendor_a": {"lines": [1, 136], "component": "Total implementation"},
          "vendor_b": {"lines": [1, 210], "component": "Total implementation"},
          "comparison": "Pydantic-AI achieves similar single-agent functionality with 35% less code"
        }
      ]
    },
    {
      "vendor_a": "pydantic-ai",
      "vendor_b": "adk-python",
      "summary": "Pydantic-AI's 136-line pattern-based approach versus ADK's 151-line traditional implementation shows modern patterns can be more concise.",
      "suitability": {
        "pydantic-ai": "When you want modern patterns and clean architecture",
        "adk-python": "When you prefer traditional, straightforward code"
      },
      "overall_winner": "pydantic-ai for modern development practices",
      "pros_cons": {
        "pydantic-ai": {
          "pros": ["Better patterns", "DI support", "More testable", "Type-safe"],
          "cons": ["Beta framework", "New patterns to learn", "More abstract"]
        },
        "adk-python": {
          "pros": ["Traditional approach", "Straightforward", "Battle-tested patterns", "Direct"],
          "cons": ["Less testable", "No DI", "Slightly more verbose"]
        }
      },
      "block_mappings": [
        {
          "description": "Dependency management",
          "vendor_a": {"lines": [25, 35], "component": "Context injection"},
          "vendor_b": {"lines": [41, 66], "component": "Direct config"},
          "comparison": "Pydantic-AI injects dependencies, ADK uses configuration"
        },
        {
          "description": "Tool pattern",
          "vendor_a": {"lines": [37, 66], "component": "Decorated methods"},
          "vendor_b": {"lines": [72, 91], "component": "Function wrappers"},
          "comparison": "Pydantic-AI uses decorators, ADK wraps functions"
        }
      ]
    },
    {
      "vendor_a": "autogen",
      "vendor_b": "adk-python",
      "summary": "AutoGen's 210-line Microsoft framework versus ADK's 151-line lightweight SDK shows the trade-off between features and simplicity.",
      "suitability": {
        "autogen": "When you need enterprise features and multi-agent support",
        "adk-python": "When you want something lighter but still structured"
      },
      "overall_winner": "autogen for enterprise, adk-python for simplicity",
      "pros_cons": {
        "autogen": {
          "pros": ["Full featured", "Multi-agent", "Microsoft backing", "Production ready"],
          "cons": ["40% more code", "Heavier framework", "More complex", "Steeper learning"]
        },
        "adk-python": {
          "pros": ["Lighter weight", "Simpler API", "Easier to learn", "Less overhead"],
          "cons": ["Fewer features", "Single agent", "Less ecosystem", "Less proven"]
        }
      },
      "block_mappings": [
        {
          "description": "Framework weight",
          "vendor_a": {"lines": [1, 210], "component": "Full implementation"},
          "vendor_b": {"lines": [1, 151], "component": "Full implementation"},
          "comparison": "AutoGen requires 40% more code for additional enterprise features"
        },
        {
          "description": "Agent setup complexity",
          "vendor_a": {"lines": [82, 126], "component": "AssistantAgent config"},
          "vendor_b": {"lines": [41, 66], "component": "Simple config"},
          "comparison": "AutoGen's 44-line config vs ADK's 25-line config"
        }
      ]
    }
  ],
  "metadata": {
    "generated": "2024-12-14",
    "total_implementations": 8,
    "comparison_count": 28,
    "purpose": "Interactive side-by-side comparison of tech writer implementations"
  }
}, null, 2)}
</tech-writer-comparison>

<tone-profile>
You are helpful, knowledgeable, and concise. You provide direct answers without unnecessary elaboration. When comparing implementations, you focus on practical differences that matter to developers. You avoid marketing speak and stick to factual comparisons based on the data provided.
</tone-profile>

Remember: Always base your answers on the comparison data provided above. Be accurate and specific when referencing implementation details, line counts, and feature comparisons.`;

        // ===== CONFIGURATION =====
    const CONFIG = {
        WORKER_URL: 'https://tech-writer-ai-proxy.julian-harris.workers.dev',
        MODEL: 'gemini-2.0-flash',
        MAX_TOKENS: 1024,
        TEMPERATURE: 0.0
    };
        class ChatWidget {
            constructor() {
                this.chatBubble = document.getElementById('chatBubble');
                this.chatWindow = document.getElementById('chatWindow');
                this.closeButton = document.getElementById('closeButton');
                this.messagesContainer = document.getElementById('messagesContainer');
                this.input = document.getElementById('chatInput');
                this.sendBtn = document.getElementById('sendButton');
                this.typingIndicator = document.getElementById('typingIndicator');
                this.chatHeader = document.querySelector('.chat-header');
                this.resizeHandle = document.getElementById('resizeHandle');
                
                this.isOpen = false;
                this.conversationHistory = [];
                this.isProcessing = false;
                this.hasInitialSystemPrompt = false;
                
                // Dragging state
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                
                // Resizing state  
                this.isResizing = false;
                this.resizeStart = { x: 0, y: 0, width: 0, height: 0 };
                
                this.init();
            }

            init() {
                // Event listeners
                this.chatBubble.addEventListener('click', () => this.toggle());
                this.closeButton.addEventListener('click', () => this.close());
                this.sendBtn.addEventListener('click', () => this.sendMessage());
                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                // Remove notification badge after first open
                this.chatBubble.addEventListener('click', () => {
                    const badge = this.chatBubble.querySelector('.notification-badge');
                    if (badge) badge.remove();
                }, { once: true });
                
                // Initialize drag functionality
                this.initDragging();
                
                // Initialize resize functionality
                this.initResizing();
            }

            toggle() {
                this.isOpen ? this.close() : this.open();
            }

            open() {
                this.chatWindow.classList.add('active');
                this.chatBubble.style.display = 'none';
                this.isOpen = true;
                this.input.focus();
            }

            close() {
                this.chatWindow.classList.remove('active');
                this.chatBubble.style.display = 'flex';
                this.isOpen = false;
            }

            sendQuickQuestion(question) {
                this.input.value = question;
                this.sendMessage();
            }

            addMessage(text, role) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.textContent = role === 'user' ? 'U' : 'AI';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = this.formatMessage(text);
                
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);
                
                // Remove welcome message if it exists
                const welcomeMsg = this.messagesContainer.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.remove();
                }
                
                this.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            formatMessage(text) {
                return text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px;">$1</code>')
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n/g, '<br>');
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'message assistant';
                typingDiv.id = 'typingIndicator';
                
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'typing-indicator';
                indicatorDiv.style.cssText = 'display: inline-flex; align-items: center; padding: 12px 16px; background: white; border: 1px solid #e0e0e0; border-radius: 15px;';
                indicatorDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                
                typingDiv.appendChild(indicatorDiv);
                this.messagesContainer.appendChild(typingDiv);
                this.scrollToBottom();
            }

            hideTypingIndicator() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            scrollToBottom() {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            async sendMessage() {
                const message = this.input.value.trim();
                if (!message || this.isProcessing) return;

                this.isProcessing = true;
                this.sendBtn.disabled = true;
                
                // Add user message
                this.addMessage(message, 'user');
                this.input.value = '';
                
                // Show typing indicator
                this.showTypingIndicator();

                try {
                    // Build conversation history for Gemini
                    const contents = this.buildContents(message);
                    
                    // Make API request
                    const response = await this.callGeminiAPI(contents);
                    
                    // Hide typing indicator
                    this.hideTypingIndicator();
                    
                    // Add response
                    this.addMessage(response, 'assistant');
                    
                    // Update conversation history
                    this.conversationHistory.push(
                        { role: 'user', content: message },
                        { role: 'assistant', content: response }
                    );
                    
                } catch (error) {
                    this.hideTypingIndicator();
                    this.addMessage(`Sorry, I encountered an error: ${error.message}`, 'assistant');
                    console.error('Chat error:', error);
                } finally {
                    this.isProcessing = false;
                    this.sendBtn.disabled = false;
                    this.input.focus();
                }
            }

            buildContents(currentMessage) {
                const contents = [];
                
                // ALWAYS include system prompt at the beginning
                contents.push({
                    role: "user",
                    parts: [{ text: systemPrompt }]
                });
                contents.push({
                    role: "model", 
                    parts: [{ text: "I understand. I'm ready to help you choose the best Python package for your AI-powered documentation needs." }]
                });
                
                // Add conversation history
                this.conversationHistory.forEach(msg => {
                    contents.push({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.content }]
                    });
                });
                
                // Add current message
                contents.push({
                    role: "user",
                    parts: [{ text: currentMessage }]
                });
                
                return contents;
            }

            async callGeminiAPI(contents) {
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: CONFIG.MODEL,
                        contents: contents,
                        generationConfig: {
                            temperature: CONFIG.TEMPERATURE,
                            maxOutputTokens: CONFIG.MAX_TOKENS
                        }
                    })
                });

                const data = await response.json();
                
                // Check if the response contains an error
                if (data.error) {
                    // Handle specific error cases with user-friendly messages
                    if (data.error.code === 503 || data.error.status === 'UNAVAILABLE') {
                        throw new Error('The AI model is currently overloaded. Please try again in a few moments.');
                    } else if (data.error.code === 429) {
                        throw new Error('Too many requests. Please wait a moment before trying again.');
                    } else if (data.error.message) {
                        throw new Error(data.error.message);
                    } else {
                        throw new Error('An unexpected error occurred. Please try again.');
                    }
                }
                
                // Check if the response has the expected structure
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0]) {
                    throw new Error('Received an invalid response from the AI model. Please try again.');
                }
                
                return data.candidates[0].content.parts[0].text;
            }
            
            // Dragging functionality
            initDragging() {
                this.chatHeader.addEventListener('mousedown', (e) => {
                    // Don't drag if clicking the close button
                    if (e.target.closest('.close-button')) return;
                    
                    this.isDragging = true;
                    const rect = this.chatWindow.getBoundingClientRect();
                    this.dragOffset.x = e.clientX - rect.left;
                    this.dragOffset.y = e.clientY - rect.top;
                    
                    // Prevent text selection while dragging
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;
                    
                    const newLeft = e.clientX - this.dragOffset.x;
                    const newTop = e.clientY - this.dragOffset.y;
                    
                    // Keep window within viewport bounds
                    const maxLeft = window.innerWidth - this.chatWindow.offsetWidth;
                    const maxTop = window.innerHeight - this.chatWindow.offsetHeight;
                    
                    this.chatWindow.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                    this.chatWindow.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
                    this.chatWindow.style.right = 'auto';
                    this.chatWindow.style.bottom = 'auto';
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });
            }
            
            // Resizing functionality
            initResizing() {
                this.resizeHandle.addEventListener('mousedown', (e) => {
                    this.isResizing = true;
                    this.resizeStart.x = e.clientX;
                    this.resizeStart.y = e.clientY;
                    this.resizeStart.width = this.chatWindow.offsetWidth;
                    this.resizeStart.height = this.chatWindow.offsetHeight;
                    
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.isResizing) return;
                    
                    const newWidth = this.resizeStart.width + (e.clientX - this.resizeStart.x);
                    const newHeight = this.resizeStart.height + (e.clientY - this.resizeStart.y);
                    
                    // Apply constraints
                    const minWidth = 300;
                    const minHeight = 400;
                    const maxWidth = window.innerWidth * 0.9;
                    const maxHeight = window.innerHeight * 0.9;
                    
                    this.chatWindow.style.width = Math.max(minWidth, Math.min(newWidth, maxWidth)) + 'px';
                    this.chatWindow.style.height = Math.max(minHeight, Math.min(newHeight, maxHeight)) + 'px';
                });
                
                document.addEventListener('mouseup', () => {
                    this.isResizing = false;
                });
            }
        }

        // Initialize chat widget when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.chatWidget = new ChatWidget();
        });
    </script>
</body>
</html>