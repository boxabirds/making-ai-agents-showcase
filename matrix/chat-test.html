<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tech Writer Agent Implementation Comparison - Powered by Gemini</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f5f5f5;
            line-height: 1.6;
        }

        /* Demo page styles */
        .demo-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .demo-content h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .demo-content p {
            color: #666;
            margin-bottom: 15px;
        }

        /* Chat Widget Styles */
        .chat-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        /* Chat Bubble Button */
        .chat-bubble {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }

        .chat-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.3);
        }

        .chat-bubble svg {
            width: 30px;
            height: 30px;
            fill: white;
        }

        /* Notification Badge */
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: #ff4757;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Chat Window */
        .chat-window {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 380px;
            height: 600px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 1001;
        }

        .chat-window.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        /* Chat Header */
        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 16px 16px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-header-info {
            display: flex;
            align-items: center;
        }

        .chat-header-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
        }

        .chat-header-avatar svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .chat-header-text h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .chat-header-text p {
            font-size: 12px;
            opacity: 0.9;
        }

        .chat-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px;
            transition: opacity 0.2s;
        }

        .chat-close:hover {
            opacity: 0.8;
        }

        .chat-close svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Chat Messages */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #f8f9fa;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .message {
            display: flex;
            margin-bottom: 16px;
            animation: messageSlide 0.3s ease;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message.assistant .message-content {
            background-color: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 4px;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: flex;
            padding: 12px 16px;
            background-color: white;
            border-radius: 18px;
            border: 1px solid #e0e0e0;
            width: fit-content;
            margin-bottom: 16px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #999;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-10px);
            }
        }

        /* Chat Input */
        .chat-input-container {
            padding: 20px;
            background-color: white;
            border-top: 1px solid #e0e0e0;
            border-radius: 0 0 16px 16px;
        }

        .chat-input-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .chat-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 24px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
            font-family: inherit;
        }

        .chat-input:focus {
            border-color: #667eea;
        }

        .chat-send {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .chat-send:hover {
            transform: scale(1.1);
        }

        .chat-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .chat-send svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .chat-window {
                width: 100%;
                height: 100%;
                right: 0;
                bottom: 0;
                border-radius: 0;
            }

            .chat-header {
                border-radius: 0;
            }

            .chat-input-container {
                border-radius: 0;
            }

            .chat-bubble {
                bottom: 20px;
                right: 20px;
            }
        }

        /* Welcome Message */
        .welcome-message {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        .welcome-message h4 {
            color: #333;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <!-- Demo Content -->
    <div class="demo-content">
        <h1>Tech Writer Agent Implementation Comparison Tool</h1>
        <p>Compare 8 different Python implementations of tech writer AI agents to find the best fit for your needs.</p>
        <p>Try our AI assistant by clicking the chat bubble in the bottom right corner!</p>
        
        <h2>Available Implementations</h2>
        <ul>
            <li><strong>Baremetal</strong> - 315 lines, full control, educational value</li>
            <li><strong>DSPy</strong> - 119 lines, declarative, minimal code</li>
            <li><strong>LangGraph</strong> - 166 lines, async, LangChain ecosystem</li>
            <li><strong>Pydantic-AI</strong> - 136 lines, clean patterns, dependency injection</li>
            <li><strong>Atomic Agents</strong> - 234 lines, type-safe, enterprise-grade</li>
            <li><strong>AutoGen</strong> - 135 lines, Microsoft framework, async</li>
            <li><strong>Agno</strong> - 104 lines, absolute minimum code</li>
            <li><strong>ADK-Python</strong> - 131 lines, Google Cloud integration</li>
        </ul>
        
        <h2>Ask About</h2>
        <ul>
            <li>Which implementation is best for production systems?</li>
            <li>Compare async vs sync implementations</li>
            <li>Type safety and schema validation options</li>
            <li>Framework dependencies and complexity</li>
            <li>Lines of code and maintainability</li>
        </ul>
    </div>

    <!-- Chat Widget -->
    <div class="chat-widget">
        <!-- Chat Bubble -->
        <div class="chat-bubble" id="chatBubble">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/>
            </svg>
            <div class="notification-badge" id="notificationBadge">1</div>
        </div>

        <!-- Chat Window -->
        <div class="chat-window" id="chatWindow">
            <!-- Header -->
            <div class="chat-header">
                <div class="chat-header-info">
                    <div class="chat-header-avatar">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 9V7c0-1.1-.9-2-2-2h-3c0-1.66-1.34-3-3-3S9 3.34 9 5H6c-1.1 0-2 .9-2 2v2c-1.66 0-3 1.34-3 3s1.34 3 3 3v4c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-4c1.66 0 3-1.34 3-3s-1.34-3-3-3z"/>
                        </svg>
                    </div>
                    <div class="chat-header-text">
                        <h3>Tech Writer Agent Expert</h3>
                        <p>Powered by Google Gemini</p>
                    </div>
                </div>
                <button class="chat-close" id="chatClose">
                    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>

            <!-- Messages -->
            <div class="chat-messages" id="chatMessages">
                <div class="welcome-message">
                    <h4>👋 Welcome!</h4>
                    <p>I'm your Tech Writer Agent Expert. I have detailed comparison data on 8 different Python implementations, analyzing everything from lines of code to architectural patterns. Ask me anything!</p>
                </div>
            </div>

            <!-- Input -->
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <input 
                        type="text" 
                        class="chat-input" 
                        id="chatInput" 
                        placeholder="Ask about tech writer agent implementations..."
                        maxlength="500"
                    >
                    <button class="chat-send" id="chatSend">
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            // Replace with your actual values
            ACCOUNT_ID: 'a98cbf2baeaa880206326429f99de63e',
            GATEWAY_ID: 'maia', // Your gateway name from the curl command
            GOOGLE_API_KEY: 'AIzaSyDsF-RuRPQlLOfSM_ubNJkr0HiXe-QddI0',
            GATEWAY_AUTH_TOKEN: null, // Optional authenticated gateway token
            MODEL: 'gemini-2.0-flash', // From your curl command
            MAX_TOKENS: 1024,
            TEMPERATURE: 0.0
        };

        // Gateway URL
        const GATEWAY_URL = `https://gateway.ai.cloudflare.com/v1/${CONFIG.ACCOUNT_ID}/${CONFIG.GATEWAY_ID}/google-ai-studio/v1/models/${CONFIG.MODEL}:generateContent`;

        // All data is now embedded in the system prompt above
        // This creates a complete serverless RAG solution

        // System prompt with complete tech writer comparison data and tone profile
        const systemPrompt = `You are a tech writer agent support agent. You host an app that helps a user compare implementations of a tech writer agent using various different open source python packages. You respond to the questions in a tone of voice profile as defined below, in response to the tech writer agent data provided, also below. Regarding answer content, as a chatbot your answers are incredibly accurate, concise and to the point.

<tech-writer-comparison>
${JSON.stringify({
  "comparisons": [
    {
      "vendor_a": "baremetal",
      "vendor_b": "atomic-agents",
      "summary": "Baremetal implements a custom ReAct agent from scratch with 315 lines of detailed control flow, while Atomic Agents leverages a framework with Pydantic schemas and structured components in 234 lines. Baremetal offers complete control but requires more boilerplate, whereas Atomic Agents provides type safety and better separation of concerns.",
      "suitability": {
        "baremetal": "Better for educational purposes, custom agent behaviors, or when you need fine-grained control over the ReAct loop",
        "atomic-agents": "Better for production systems requiring type safety, schema validation, and standardized agent patterns"
      },
      "overall_winner": "atomic-agents for most use cases due to better maintainability and type safety",
      "pros_cons": {
        "baremetal": {
          "pros": ["Complete control over agent behavior", "No framework dependencies", "Educational value", "Direct API integration"],
          "cons": ["More code to maintain", "Manual error handling", "No type safety", "Reinventing the wheel"]
        },
        "atomic-agents": {
          "pros": ["Type-safe with Pydantic", "Structured tool definitions", "Framework handles boilerplate", "Better separation of concerns"],
          "cons": ["Framework learning curve", "More dependencies", "Less flexibility for custom behaviors", "Heavier setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Agent class definition",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [154, 196], "component": "TechWriterAgent class"},
          "comparison": "Baremetal's 248-line class implements full ReAct logic manually, while Atomic's 42-line class leverages framework abstractions"
        },
        {
          "description": "Tool definition approach",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions method"},
          "vendor_b": {"lines": [53, 123], "component": "Tool schema classes"},
          "comparison": "Baremetal uses introspection to create OpenAI tool definitions (87 lines), Atomic uses Pydantic schemas (70 lines) for type-safe tools"
        },
        {
          "description": "LLM client initialization",
          "vendor_a": {"lines": [26, 49], "component": "__init__ with vendor detection"},
          "vendor_b": {"lines": [158, 159], "component": "instructor.from_litellm"},
          "comparison": "Baremetal manually handles vendor detection in 23 lines, Atomic delegates to LiteLLM in 2 lines"
        },
        {
          "description": "Agent execution loop",
          "vendor_a": {"lines": [226, 273], "component": "run method with ReAct loop"},
          "vendor_b": {"lines": [192, 194], "component": "agent.run call"},
          "comparison": "Baremetal implements full ReAct loop in 47 lines, Atomic delegates to framework in 3 lines"
        },
        {
          "description": "Tool execution",
          "vendor_a": {"lines": [192, 223], "component": "execute_tool method"},
          "vendor_b": {"lines": [77, 92], "component": "Tool run methods"},
          "comparison": "Baremetal has centralized tool execution (31 lines), Atomic has per-tool run methods (15 lines each)"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "dspy",
      "summary": "Baremetal's 315-line implementation provides complete control over the ReAct pattern, while DSPy achieves the same functionality in just 119 lines using its declarative signature-based approach. DSPy's conciseness comes from abstracting away the agent loop entirely.",
      "suitability": {
        "baremetal": "When you need to understand or customize ReAct implementation details",
        "dspy": "When you want the simplest possible implementation with minimal code"
      },
      "overall_winner": "dspy for simplicity and maintainability",
      "pros_cons": {
        "baremetal": {
          "pros": ["Full visibility into ReAct logic", "Customizable behavior", "No DSPy learning curve"],
          "cons": ["10x more code", "Manual implementation of standard patterns", "More potential for bugs"]
        },
        "dspy": {
          "pros": ["Extremely concise", "Declarative approach", "Built-in ReAct", "Automatic optimization potential"],
          "cons": ["Black box ReAct implementation", "DSPy-specific patterns", "Less control"]
        }
      },
      "block_mappings": [
        {
          "description": "Entire agent implementation",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [40, 81], "component": "TechWriterSignature class"},
          "comparison": "Baremetal's 248-line class vs DSPy's 41-line signature - DSPy achieves same result with 83% less code"
        },
        {
          "description": "ReAct pattern implementation",
          "vendor_a": {"lines": [226, 273], "component": "run method"},
          "vendor_b": {"lines": [91, 93], "component": "dspy.ReAct instantiation"},
          "comparison": "Baremetal implements ReAct loop in 47 lines, DSPy uses built-in ReAct in 3 lines"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [93, 93], "component": "tools=TOOLS parameter"},
          "comparison": "Baremetal converts tools in 87 lines, DSPy passes tools directly in 1 line"
        }
      ]
    },
    {
      "vendor_a": "baremetal", 
      "vendor_b": "langgraph",
      "summary": "Baremetal's 315-line synchronous implementation contrasts with LangGraph's 166-line async implementation using pre-built components. LangGraph provides a middle ground between raw implementation and high abstraction.",
      "suitability": {
        "baremetal": "When async isn't needed and you want direct control",
        "langgraph": "When building async workflows with LangChain ecosystem integration"
      },
      "overall_winner": "langgraph for modern async applications",
      "pros_cons": {
        "baremetal": {
          "pros": ["Simpler synchronous model", "No LangChain dependencies", "Direct OpenAI integration"],
          "cons": ["No async support", "Manual ReAct implementation", "More code"]
        },
        "langgraph": {
          "pros": ["Async native", "Pre-built ReAct agent", "LangChain ecosystem", "Streaming support"],
          "cons": ["LangChain dependency weight", "More complex setup", "Async complexity"]
        }
      },
      "block_mappings": [
        {
          "description": "Main analysis function",
          "vendor_a": {"lines": [276, 294], "component": "analyse_codebase (sync)"},
          "vendor_b": {"lines": [36, 123], "component": "analyze_codebase (async)"},
          "comparison": "Baremetal's 18-line sync function vs LangGraph's 87-line async function with streaming"
        },
        {
          "description": "Tool wrapper approach",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [63, 96], "component": "Inline tool wrappers"},
          "comparison": "Baremetal introspects in 87 lines, LangGraph wraps inline in 33 lines"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [26, 54], "component": "Class __init__"},
          "vendor_b": {"lines": [97, 118], "component": "create_react_agent call"},
          "comparison": "Baremetal initializes in constructor (28 lines), LangGraph uses factory function (21 lines)"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "pydantic-ai",
      "summary": "Baremetal's imperative 315-line implementation contrasts sharply with Pydantic-AI's decorator-based 136-line approach. Pydantic-AI offers a more Pythonic, type-safe solution with dependency injection.",
      "suitability": {
        "baremetal": "When you need explicit control flow and don't want framework magic",
        "pydantic-ai": "When you want clean, testable code with dependency injection"
      },
      "overall_winner": "pydantic-ai for clean architecture and testability",
      "pros_cons": {
        "baremetal": {
          "pros": ["Explicit control flow", "No decorator magic", "Clear execution path"],
          "cons": ["Verbose implementation", "Manual dependency management", "Harder to test"]
        },
        "pydantic-ai": {
          "pros": ["Clean decorator syntax", "Dependency injection", "Type-safe context", "Testable"],
          "cons": ["Framework conventions", "Decorator complexity", "Hidden control flow"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool definition style",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [37, 66], "component": "@tech_writer.tool decorators"},
          "comparison": "Baremetal's 87-line introspection vs Pydantic-AI's 29-line decorator approach"
        },
        {
          "description": "Context management",
          "vendor_a": {"lines": [29, 29], "component": "self.memory list"},
          "vendor_b": {"lines": [25, 36], "component": "AnalysisContext model"},
          "comparison": "Baremetal uses simple list, Pydantic-AI uses 11-line typed context model"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [226, 273], "component": "run method"},
          "vendor_b": {"lines": [84, 90], "component": "tech_writer.run"},
          "comparison": "Baremetal's 47-line manual loop vs Pydantic-AI's 6-line framework call"
        }
      ]
    },
    {
      "vendor_a": "atomic-agents",
      "vendor_b": "dspy",
      "summary": "Atomic Agents' 234-line enterprise-grade implementation with full type safety contrasts with DSPy's minimalist 119-line approach. This represents the spectrum from maximum structure to maximum simplicity.",
      "suitability": {
        "atomic-agents": "Large teams needing type safety and standardization",
        "dspy": "Rapid prototyping and research applications"
      },
      "overall_winner": "Depends on context - atomic-agents for production, dspy for simplicity",
      "pros_cons": {
        "atomic-agents": {
          "pros": ["Full type safety", "Structured schemas", "Enterprise patterns", "Tool validation"],
          "cons": ["Verbose setup", "Heavy boilerplate", "Steeper learning curve"]
        },
        "dspy": {
          "pros": ["Minimal code", "Quick to implement", "Clear intent", "Low overhead"],
          "cons": ["No type checking", "Limited structure", "Less validation"]
        }
      },
      "block_mappings": [
        {
          "description": "Schema definitions",
          "vendor_a": {"lines": [34, 123], "component": "Multiple schema classes"},
          "vendor_b": {"lines": [40, 81], "component": "Single signature class"},
          "comparison": "Atomic's 89 lines of schemas vs DSPy's 41-line signature"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [53, 123], "component": "Tool classes with schemas"},
          "vendor_b": {"lines": [93, 93], "component": "tools=TOOLS"},
          "comparison": "Atomic's 70-line tool classes vs DSPy's 1-line parameter"
        },
        {
          "description": "Framework setup",
          "vendor_a": {"lines": [154, 180], "component": "TechWriterAgent.__init__"},
          "vendor_b": {"lines": [91, 93], "component": "dspy.ReAct creation"},
          "comparison": "Atomic's 26-line setup vs DSPy's 3-line instantiation"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "autogen",
      "summary": "Both async implementations take different approaches: LangGraph's 166 lines use LangChain's ecosystem with functional style, while AutoGen's 135 lines use Microsoft's agent framework with minimal wrapper functions.",
      "suitability": {
        "langgraph": "When already using LangChain or needing graph-based workflows",
        "autogen": "When wanting Microsoft's agent patterns or simpler async integration"
      },
      "overall_winner": "autogen for simplicity, langgraph for ecosystem",
      "pros_cons": {
        "langgraph": {
          "pros": ["Rich LangChain ecosystem", "Graph-based workflows", "Streaming support"],
          "cons": ["Heavier dependencies", "More complex setup", "LangChain lock-in"]
        },
        "autogen": {
          "pros": ["Simpler async model", "Microsoft backing", "Cleaner code", "Less dependencies"],
          "cons": ["Less ecosystem", "Fewer advanced features", "Less documentation"]
        }
      },
      "block_mappings": [
        {
          "description": "Async tool wrappers",
          "vendor_a": {"lines": [63, 96], "component": "Inline async wrappers"},
          "vendor_b": {"lines": [31, 50], "component": "Top-level async wrappers"},
          "comparison": "LangGraph's 33-line inline wrappers vs AutoGen's 19-line module-level wrappers"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [97, 118], "component": "create_react_agent"},
          "vendor_b": {"lines": [70, 86], "component": "AssistantAgent creation"},
          "comparison": "LangGraph's 21-line setup vs AutoGen's 16-line configuration"
        },
        {
          "description": "Main async structure",
          "vendor_a": {"lines": [125, 166], "component": "Nested async main"},
          "vendor_b": {"lines": [84, 124], "component": "Nested async main"},
          "comparison": "Both use similar 40-line nested async patterns"
        }
      ]
    },
    {
      "vendor_a": "pydantic-ai",
      "vendor_b": "agno",
      "summary": "Pydantic-AI's 136-line decorator-based approach with dependency injection contrasts with Agno's ultra-minimal 104-line implementation. Agno achieves brevity through simplicity while Pydantic-AI adds structure.",
      "suitability": {
        "pydantic-ai": "When you want clean patterns and testability",
        "agno": "When you want the absolute minimum code that works"
      },
      "overall_winner": "agno for simplicity, pydantic-ai for maintainability",
      "pros_cons": {
        "pydantic-ai": {
          "pros": ["Dependency injection", "Decorator elegance", "Type-safe context", "Testable"],
          "cons": ["More complex patterns", "Framework learning curve", "More lines of code"]
        },
        "agno": {
          "pros": ["Minimal code", "Direct approach", "Easy to understand", "Few dependencies"],
          "cons": ["Less structure", "No dependency injection", "Less extensible"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [37, 66], "component": "Decorated tool functions"},
          "vendor_b": {"lines": [59, 59], "component": "tools parameter"},
          "comparison": "Pydantic-AI's 29-line decorators vs Agno's 1-line parameter"
        },
        {
          "description": "Model setup",
          "vendor_a": {"lines": [31, 31], "component": "Direct model string"},
          "vendor_b": {"lines": [36, 53], "component": "ModelFactory class"},
          "comparison": "Pydantic-AI's 1-line model vs Agno's 17-line factory (for multi-vendor support)"
        },
        {
          "description": "Context passing",
          "vendor_a": {"lines": [25, 36], "component": "AnalysisContext class"},
          "vendor_b": {"lines": [70, 70], "component": "Inline prompt"},
          "comparison": "Pydantic-AI's 11-line context model vs Agno's inline approach"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "dspy",
      "summary": "Google's ADK implementation (131 lines) uses async patterns and session management, while DSPy (119 lines) keeps everything synchronous and declarative. Both achieve similar brevity through framework abstractions.",
      "suitability": {
        "adk-python": "When building Google-cloud-first applications with async needs",
        "dspy": "When you want maximum simplicity and don't need async"
      },
      "overall_winner": "dspy for simplicity, adk-python for Google ecosystem",
      "pros_cons": {
        "adk-python": {
          "pros": ["Google integration", "Async support", "Session management", "Memory runner"],
          "cons": ["Google-specific patterns", "Model naming workarounds", "More complex setup"]
        },
        "dspy": {
          "pros": ["Simpler sync model", "Cleaner code", "No vendor lock-in", "Declarative"],
          "cons": ["No async", "Less ecosystem integration", "Black-box ReAct"]
        }
      },
      "block_mappings": [
        {
          "description": "Model setup approach",
          "vendor_a": {"lines": [32, 45], "component": "stupid_adk_hack_to_get_model"},
          "vendor_b": {"lines": [89, 89], "component": "Direct dspy.configure"},
          "comparison": "ADK's 13-line workaround vs DSPy's 1-line configuration"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [83, 96], "component": "Runner with session"},
          "vendor_b": {"lines": [91, 93], "component": "Direct ReAct call"},
          "comparison": "ADK's 13-line session management vs DSPy's 3-line execution"
        },
        {
          "description": "Main function structure",
          "vendor_a": {"lines": [103, 131], "component": "Async main"},
          "vendor_b": {"lines": [99, 119], "component": "Sync main"},
          "comparison": "ADK's 28-line async main vs DSPy's 20-line sync main"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "adk-python",
      "summary": "Baremetal's 315-line synchronous implementation with manual ReAct contrasts with ADK's 131-line async implementation using Google's agent framework. ADK provides session management and memory runners but requires Google-specific patterns.",
      "suitability": {
        "baremetal": "When you need vendor-agnostic implementation with full control",
        "adk-python": "When building Google-cloud-first applications with built-in persistence"
      },
      "overall_winner": "baremetal for flexibility, adk-python for Google ecosystem",
      "pros_cons": {
        "baremetal": {
          "pros": ["Vendor neutral", "Direct control", "No framework dependencies", "Simpler sync model"],
          "cons": ["More boilerplate", "No built-in persistence", "Manual everything", "No async"]
        },
        "adk-python": {
          "pros": ["Google integration", "Session management", "Memory persistence", "Async native"],
          "cons": ["Google-specific", "Model naming hacks", "Framework complexity", "Limited to Google patterns"]
        }
      },
      "block_mappings": [
        {
          "description": "Model initialization",
          "vendor_a": {"lines": [26, 49], "component": "Vendor detection in __init__"},
          "vendor_b": {"lines": [32, 45], "component": "stupid_adk_hack_to_get_model"},
          "comparison": "Baremetal's 23-line vendor detection vs ADK's 13-line hack for model compatibility"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [226, 273], "component": "run method with ReAct loop"},
          "vendor_b": {"lines": [83, 96], "component": "Runner async execution"},
          "comparison": "Baremetal's 47-line manual ReAct vs ADK's 13-line framework execution"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [56, 56], "component": "tools parameter"},
          "comparison": "Baremetal's 87-line tool conversion vs ADK's 1-line tool list"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "agno",
      "summary": "Baremetal's 315-line explicit implementation contrasts sharply with Agno's 104-line minimalist approach. Agno achieves extreme brevity through its framework abstractions while Baremetal provides complete transparency.",
      "suitability": {
        "baremetal": "When you need to understand or customize every aspect of the agent",
        "agno": "When you want the absolute minimum code that just works"
      },
      "overall_winner": "agno for simplicity, baremetal for control",
      "pros_cons": {
        "baremetal": {
          "pros": ["Complete transparency", "No magic", "Educational value", "Full customization"],
          "cons": ["3x more code", "Manual implementation", "More maintenance", "Verbose"]
        },
        "agno": {
          "pros": ["Minimal code", "Quick setup", "Clean API", "Low cognitive load"],
          "cons": ["Hidden complexity", "Less control", "Framework dependency", "Limited customization"]
        }
      },
      "block_mappings": [
        {
          "description": "Entire implementation",
          "vendor_a": {"lines": [1, 315], "component": "Full implementation"},
          "vendor_b": {"lines": [1, 104], "component": "Full implementation"},
          "comparison": "Baremetal uses 315 lines vs Agno's 104 lines - 67% reduction"
        },
        {
          "description": "Agent setup and execution",
          "vendor_a": {"lines": [25, 273], "component": "TechWriterReActAgent class"},
          "vendor_b": {"lines": [59, 67], "component": "Agent instantiation and run"},
          "comparison": "Baremetal's 248-line class vs Agno's 8-line setup"
        },
        {
          "description": "Model configuration",
          "vendor_a": {"lines": [33, 49], "component": "Vendor-specific client setup"},
          "vendor_b": {"lines": [36, 53], "component": "ModelFactory pattern"},
          "comparison": "Both use similar lines (16-17) but different approaches"
        }
      ]
    },
    {
      "vendor_a": "baremetal",
      "vendor_b": "autogen",
      "summary": "Baremetal's 315-line synchronous implementation with manual ReAct contrasts with AutoGen's 135-line async approach using Microsoft's agent framework. AutoGen provides cleaner async patterns with minimal wrapper code.",
      "suitability": {
        "baremetal": "When you need synchronous execution and full control",
        "autogen": "When you want async support with Microsoft's agent patterns"
      },
      "overall_winner": "autogen for modern async applications",
      "pros_cons": {
        "baremetal": {
          "pros": ["Sync simplicity", "No framework magic", "Direct control", "Clear execution flow"],
          "cons": ["No async", "Manual ReAct", "More code", "No framework benefits"]
        },
        "autogen": {
          "pros": ["Async native", "Clean code", "Microsoft backing", "Minimal boilerplate"],
          "cons": ["Async complexity", "Framework dependency", "Less transparency", "Microsoft patterns"]
        }
      },
      "block_mappings": [
        {
          "description": "Main execution pattern",
          "vendor_a": {"lines": [276, 294], "component": "Sync analyse_codebase"},
          "vendor_b": {"lines": [65, 92], "component": "Async analyze_codebase"},
          "comparison": "Baremetal's 18-line sync vs AutoGen's 27-line async function"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [56, 143], "component": "create_openai_tool_definitions"},
          "vendor_b": {"lines": [33, 62], "component": "Async tool wrappers"},
          "comparison": "Baremetal's 87-line conversion vs AutoGen's 29-line async wrappers"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [25, 54], "component": "TechWriterReActAgent.__init__"},
          "vendor_b": {"lines": [79, 85], "component": "AssistantAgent creation"},
          "comparison": "Baremetal's 29-line init vs AutoGen's 6-line agent setup"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "agno",
      "summary": "Both achieve similar brevity (131 vs 104 lines) but through different means: ADK uses Google's async agent framework with sessions, while Agno uses a minimalist sync approach. ADK adds complexity for persistence features Agno doesn't offer.",
      "suitability": {
        "adk-python": "When you need Google Cloud integration and session persistence",
        "agno": "When you want the simplest possible sync implementation"
      },
      "overall_winner": "agno for simplicity, adk-python for features",
      "pros_cons": {
        "adk-python": {
          "pros": ["Session management", "Memory persistence", "Google ecosystem", "Async support"],
          "cons": ["Model naming hacks", "More complex setup", "Google lock-in", "Async overhead"]
        },
        "agno": {
          "pros": ["Simpler code", "Vendor neutral", "Sync simplicity", "Clean API"],
          "cons": ["No persistence", "No sessions", "Limited features", "No async"]
        }
      },
      "block_mappings": [
        {
          "description": "Model setup",
          "vendor_a": {"lines": [32, 45], "component": "stupid_adk_hack_to_get_model"},
          "vendor_b": {"lines": [36, 53], "component": "ModelFactory.create"},
          "comparison": "ADK's 13-line hack vs Agno's 17-line factory pattern"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [83, 96], "component": "Runner with session"},
          "vendor_b": {"lines": [67, 67], "component": "agent.run"},
          "comparison": "ADK's 13-line session-based execution vs Agno's 1-line run"
        },
        {
          "description": "Main function structure",
          "vendor_a": {"lines": [103, 131], "component": "Async main"},
          "vendor_b": {"lines": [77, 104], "component": "Sync main"},
          "comparison": "ADK's 28-line async main vs Agno's 27-line sync main"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "langgraph",
      "summary": "Both async implementations take different approaches: ADK's 131 lines use Google's session-based framework, while LangGraph's 166 lines leverage LangChain's graph-based agents. LangGraph offers more flexibility while ADK provides persistence.",
      "suitability": {
        "adk-python": "When building Google Cloud applications with persistence needs",
        "langgraph": "When you need LangChain ecosystem and graph-based workflows"
      },
      "overall_winner": "langgraph for flexibility, adk-python for Google integration",
      "pros_cons": {
        "adk-python": {
          "pros": ["Built-in persistence", "Session management", "Google integration", "Simpler setup"],
          "cons": ["Google-specific", "Model naming issues", "Limited flexibility", "Framework lock-in"]
        },
        "langgraph": {
          "pros": ["LangChain ecosystem", "Graph workflows", "More flexible", "Better tool handling"],
          "cons": ["More dependencies", "Complex setup", "No built-in persistence", "Heavier framework"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [56, 56], "component": "tools parameter"},
          "vendor_b": {"lines": [63, 96], "component": "Tool wrapper functions"},
          "comparison": "ADK's 1-line tool list vs LangGraph's 33-line wrapper functions"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [51, 60], "component": "Agent instantiation"},
          "vendor_b": {"lines": [98, 101], "component": "create_react_agent"},
          "comparison": "ADK's 9-line agent setup vs LangGraph's 3-line creation"
        },
        {
          "description": "Execution pattern",
          "vendor_a": {"lines": [89, 95], "component": "Streaming execution"},
          "vendor_b": {"lines": [111, 118], "component": "Agent invoke"},
          "comparison": "ADK's 6-line streaming vs LangGraph's 7-line invocation"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "pydantic-ai",
      "summary": "ADK's 131-line Google-specific implementation contrasts with Pydantic-AI's 136-line decorator-based approach. Both are similar in length but Pydantic-AI offers cleaner patterns while ADK provides persistence.",
      "suitability": {
        "adk-python": "When you need Google Cloud features and session management",
        "pydantic-ai": "When you want clean, testable code with dependency injection"
      },
      "overall_winner": "pydantic-ai for code quality, adk-python for Google features",
      "pros_cons": {
        "adk-python": {
          "pros": ["Session persistence", "Google integration", "Memory runners", "Built-in state"],
          "cons": ["Model naming hacks", "Google lock-in", "Complex setup", "Framework overhead"]
        },
        "pydantic-ai": {
          "pros": ["Clean decorators", "Dependency injection", "Type safety", "Testable"],
          "cons": ["No persistence", "No sessions", "Framework learning", "Hidden control flow"]
        }
      },
      "block_mappings": [
        {
          "description": "Context/dependency handling",
          "vendor_a": {"lines": [69, 73], "component": "Session creation"},
          "vendor_b": {"lines": [25, 29], "component": "AnalysisContext model"},
          "comparison": "ADK's 4-line session vs Pydantic-AI's 4-line context model"
        },
        {
          "description": "Tool definition",
          "vendor_a": {"lines": [56, 56], "component": "tools list"},
          "vendor_b": {"lines": [37, 66], "component": "Decorated tool functions"},
          "comparison": "ADK's 1-line list vs Pydantic-AI's 29-line decorators"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [89, 95], "component": "Streaming runner"},
          "vendor_b": {"lines": [86, 90], "component": "tech_writer.run"},
          "comparison": "ADK's 6-line streaming vs Pydantic-AI's 4-line run"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "autogen",
      "summary": "Both async implementations are similar in length (131 vs 135 lines) but differ in approach: ADK uses Google's session-based framework while AutoGen uses Microsoft's simpler agent patterns without persistence.",
      "suitability": {
        "adk-python": "When you need Google Cloud integration with state persistence",
        "autogen": "When you want straightforward async agents without framework complexity"
      },
      "overall_winner": "autogen for simplicity, adk-python for features",
      "pros_cons": {
        "adk-python": {
          "pros": ["Session management", "State persistence", "Google ecosystem", "Memory runners"],
          "cons": ["Model naming hacks", "Complex setup", "Google-specific", "More boilerplate"]
        },
        "autogen": {
          "pros": ["Cleaner code", "Simple async", "Vendor neutral", "Direct approach"],
          "cons": ["No persistence", "No sessions", "Basic features", "Less ecosystem"]
        }
      },
      "block_mappings": [
        {
          "description": "Model setup",
          "vendor_a": {"lines": [32, 45], "component": "stupid_adk_hack_to_get_model"},
          "vendor_b": {"lines": [74, 76], "component": "OpenAIChatCompletionClient"},
          "comparison": "ADK's 13-line hack vs AutoGen's 2-line client creation"
        },
        {
          "description": "Agent initialization",
          "vendor_a": {"lines": [51, 73], "component": "Agent + Runner + Session"},
          "vendor_b": {"lines": [79, 85], "component": "AssistantAgent creation"},
          "comparison": "ADK's 22-line setup vs AutoGen's 6-line agent"
        },
        {
          "description": "Execution pattern",
          "vendor_a": {"lines": [89, 95], "component": "Streaming with session"},
          "vendor_b": {"lines": [88, 89], "component": "agent.run"},
          "comparison": "ADK's 6-line streaming vs AutoGen's 1-line run"
        }
      ]
    },
    {
      "vendor_a": "adk-python",
      "vendor_b": "atomic-agents",
      "summary": "ADK's 131-line Google-specific async implementation contrasts with Atomic Agents' 234-line type-safe sync approach. Atomic provides extensive type safety and structure while ADK focuses on Google Cloud integration.",
      "suitability": {
        "adk-python": "When building Google Cloud applications with async needs",
        "atomic-agents": "When type safety and structured patterns are priorities"
      },
      "overall_winner": "atomic-agents for enterprise apps, adk-python for Google Cloud",
      "pros_cons": {
        "adk-python": {
          "pros": ["Google integration", "Async native", "Session management", "Concise code"],
          "cons": ["Model hacks", "Google lock-in", "Less type safety", "Limited structure"]
        },
        "atomic-agents": {
          "pros": ["Full type safety", "Pydantic schemas", "Clear structure", "Enterprise patterns"],
          "cons": ["More verbose", "Sync only", "Heavy boilerplate", "Complex setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Type definitions",
          "vendor_a": {"lines": [50, 50], "component": "No explicit types"},
          "vendor_b": {"lines": [34, 123], "component": "Schema definitions"},
          "comparison": "ADK has no schemas vs Atomic's 89 lines of type definitions"
        },
        {
          "description": "Agent setup",
          "vendor_a": {"lines": [51, 60], "component": "Agent creation"},
          "vendor_b": {"lines": [170, 182], "component": "BaseAgent config"},
          "comparison": "ADK's 9-line setup vs Atomic's 12-line configuration"
        },
        {
          "description": "Tool handling",
          "vendor_a": {"lines": [56, 56], "component": "tools list"},
          "vendor_b": {"lines": [66, 123], "component": "Tool classes"},
          "comparison": "ADK's 1-line list vs Atomic's 57-line tool implementations"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "agno",
      "summary": "Both ultra-minimal implementations achieve similar brevity (119 vs 104 lines) through framework abstractions. DSPy uses declarative signatures while Agno uses direct agent instantiation.",
      "suitability": {
        "dspy": "When you want declarative patterns and potential optimization",
        "agno": "When you want the absolute simplest imperative code"
      },
      "overall_winner": "agno for simplicity, dspy for advanced features",
      "pros_cons": {
        "dspy": {
          "pros": ["Declarative approach", "Built-in ReAct", "Optimization potential", "Research-friendly"],
          "cons": ["Docstring prompts", "Black box ReAct", "DSPy learning curve", "Less direct"]
        },
        "agno": {
          "pros": ["Most concise", "Direct approach", "Easy to understand", "Minimal dependencies"],
          "cons": ["Less features", "No optimization", "Basic functionality", "Limited extensibility"]
        }
      },
      "block_mappings": [
        {
          "description": "Complete implementation",
          "vendor_a": {"lines": [1, 119], "component": "Full file"},
          "vendor_b": {"lines": [1, 104], "component": "Full file"},
          "comparison": "DSPy uses 119 lines vs Agno's 104 lines - both extremely concise"
        },
        {
          "description": "Agent/Signature definition",
          "vendor_a": {"lines": [40, 81], "component": "TechWriterSignature class"},
          "vendor_b": {"lines": [59, 64], "component": "Agent instantiation"},
          "comparison": "DSPy's 41-line signature vs Agno's 5-line agent setup"
        },
        {
          "description": "Execution",
          "vendor_a": {"lines": [91, 93], "component": "ReAct execution"},
          "vendor_b": {"lines": [67, 67], "component": "agent.run"},
          "comparison": "DSPy's 3-line ReAct vs Agno's 1-line run"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "langgraph",
      "summary": "DSPy's 119-line declarative approach contrasts with LangGraph's 166-line async implementation. DSPy achieves brevity through signatures while LangGraph provides async graph-based workflows.",
      "suitability": {
        "dspy": "When you want minimal declarative code without async complexity",
        "langgraph": "When you need async support and LangChain integration"
      },
      "overall_winner": "dspy for simplicity, langgraph for production async",
      "pros_cons": {
        "dspy": {
          "pros": ["Extremely concise", "Declarative", "No async complexity", "Clear intent"],
          "cons": ["No async", "Docstring prompts", "Limited control", "Black box"]
        },
        "langgraph": {
          "pros": ["Async native", "LangChain ecosystem", "Graph workflows", "More control"],
          "cons": ["More complex", "Heavier dependencies", "Verbose setup", "Async overhead"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [93, 93], "component": "tools parameter"},
          "vendor_b": {"lines": [63, 96], "component": "Tool wrapper functions"},
          "comparison": "DSPy's 1-line parameter vs LangGraph's 33-line wrappers"
        },
        {
          "description": "Main execution",
          "vendor_a": {"lines": [99, 119], "component": "Sync main"},
          "vendor_b": {"lines": [125, 166], "component": "Async main"},
          "comparison": "DSPy's 20-line sync main vs LangGraph's 41-line async main"
        },
        {
          "description": "Agent pattern",
          "vendor_a": {"lines": [40, 81], "component": "Signature-based"},
          "vendor_b": {"lines": [98, 114], "component": "Graph-based agent"},
          "comparison": "DSPy's 41-line signature vs LangGraph's 16-line agent setup"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "pydantic-ai",
      "summary": "Both achieve similar brevity (119 vs 136 lines) but through different patterns: DSPy uses declarative signatures while Pydantic-AI uses decorators and dependency injection for cleaner architecture.",
      "suitability": {
        "dspy": "When you want minimal declarative code",
        "pydantic-ai": "When you want testable code with clean patterns"
      },
      "overall_winner": "pydantic-ai for maintainability, dspy for minimalism",
      "pros_cons": {
        "dspy": {
          "pros": ["More concise", "Declarative", "Built-in ReAct", "Simple setup"],
          "cons": ["Docstring prompts", "Less testable", "Black box", "Limited DI"]
        },
        "pydantic-ai": {
          "pros": ["Dependency injection", "Decorator elegance", "Testable", "Type-safe context"],
          "cons": ["Slightly more code", "Framework patterns", "Hidden flow", "More complex"]
        }
      },
      "block_mappings": [
        {
          "description": "Prompt/Context definition",
          "vendor_a": {"lines": [40, 81], "component": "Docstring prompt"},
          "vendor_b": {"lines": [25, 29], "component": "Context class"},
          "comparison": "DSPy's 41-line docstring vs Pydantic-AI's 4-line context"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [93, 93], "component": "tools parameter"},
          "vendor_b": {"lines": [37, 66], "component": "Decorated tools"},
          "comparison": "DSPy's 1-line parameter vs Pydantic-AI's 29-line decorators"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [91, 93], "component": "ReAct instantiation"},
          "vendor_b": {"lines": [31, 35], "component": "Agent definition"},
          "comparison": "DSPy's 3-line setup vs Pydantic-AI's 4-line agent"
        }
      ]
    },
    {
      "vendor_a": "dspy",
      "vendor_b": "autogen",
      "summary": "DSPy's 119-line sync implementation with declarative signatures contrasts with AutoGen's 135-line async approach. Both are concise but AutoGen adds async complexity for modern applications.",
      "suitability": {
        "dspy": "When you want the simplest sync implementation",
        "autogen": "When you need async support with minimal overhead"
      },
      "overall_winner": "dspy for simplicity, autogen for async needs",
      "pros_cons": {
        "dspy": {
          "pros": ["More concise", "Simpler sync model", "Declarative", "No async complexity"],
          "cons": ["No async support", "Docstring prompts", "Less flexible", "Black box"]
        },
        "autogen": {
          "pros": ["Async native", "Clean patterns", "Microsoft backing", "More flexible"],
          "cons": ["Async complexity", "Slightly more code", "Framework dependency", "More setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Implementation approach",
          "vendor_a": {"lines": [40, 81], "component": "Signature class"},
          "vendor_b": {"lines": [33, 62], "component": "Async wrappers"},
          "comparison": "DSPy's 41-line signature vs AutoGen's 29-line async wrappers"
        },
        {
          "description": "Agent setup",
          "vendor_a": {"lines": [91, 93], "component": "ReAct creation"},
          "vendor_b": {"lines": [79, 85], "component": "AssistantAgent"},
          "comparison": "DSPy's 3-line setup vs AutoGen's 6-line configuration"
        },
        {
          "description": "Main structure",
          "vendor_a": {"lines": [99, 119], "component": "Sync main"},
          "vendor_b": {"lines": [95, 135], "component": "Nested async main"},
          "comparison": "DSPy's 20-line sync vs AutoGen's 40-line async pattern"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "langgraph",
      "summary": "Agno's 104-line minimal sync implementation contrasts sharply with LangGraph's 166-line async approach. Agno wins on simplicity while LangGraph provides async and ecosystem benefits.",
      "suitability": {
        "agno": "When you want the absolute minimum working code",
        "langgraph": "When you need async and LangChain ecosystem"
      },
      "overall_winner": "agno for simplicity, langgraph for features",
      "pros_cons": {
        "agno": {
          "pros": ["Most concise", "Simple sync", "Direct approach", "Easy to understand"],
          "cons": ["No async", "Limited features", "Basic functionality", "No ecosystem"]
        },
        "langgraph": {
          "pros": ["Async support", "Rich ecosystem", "Graph workflows", "Streaming"],
          "cons": ["60% more code", "Complex setup", "Heavy dependencies", "Async overhead"]
        }
      },
      "block_mappings": [
        {
          "description": "Complete implementation",
          "vendor_a": {"lines": [1, 104], "component": "Full file"},
          "vendor_b": {"lines": [1, 166], "component": "Full file"},
          "comparison": "Agno's 104 lines vs LangGraph's 166 lines - 60% more code"
        },
        {
          "description": "Tool handling",
          "vendor_a": {"lines": [62, 62], "component": "tools parameter"},
          "vendor_b": {"lines": [63, 96], "component": "Tool wrappers"},
          "comparison": "Agno's 1-line parameter vs LangGraph's 33-line wrappers"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [67, 67], "component": "agent.run"},
          "vendor_b": {"lines": [111, 118], "component": "agent.invoke"},
          "comparison": "Agno's 1-line run vs LangGraph's 7-line invocation"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "autogen",
      "summary": "Agno's 104-line sync implementation is even more minimal than AutoGen's 135-line async approach. Both are clean but serve different needs: Agno for simplicity, AutoGen for async.",
      "suitability": {
        "agno": "When sync is fine and you want minimal code",
        "autogen": "When you need async with clean patterns"
      },
      "overall_winner": "agno for minimalism, autogen for async apps",
      "pros_cons": {
        "agno": {
          "pros": ["Most minimal", "Sync simplicity", "Direct API", "Low complexity"],
          "cons": ["No async", "Basic features", "Limited extensibility", "Less powerful"]
        },
        "autogen": {
          "pros": ["Async support", "Clean code", "More features", "Microsoft patterns"],
          "cons": ["More complex", "Async overhead", "More dependencies", "Verbose setup"]
        }
      },
      "block_mappings": [
        {
          "description": "Model setup",
          "vendor_a": {"lines": [36, 53], "component": "ModelFactory"},
          "vendor_b": {"lines": [74, 76], "component": "OpenAIChatCompletionClient"},
          "comparison": "Agno's 17-line factory vs AutoGen's 2-line client"
        },
        {
          "description": "Main function",
          "vendor_a": {"lines": [77, 104], "component": "Sync main"},
          "vendor_b": {"lines": [95, 135], "component": "Async main wrapper"},
          "comparison": "Agno's 27-line sync vs AutoGen's 40-line async"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [59, 74], "component": "Agent setup and run"},
          "vendor_b": {"lines": [79, 92], "component": "AssistantAgent and run"},
          "comparison": "Agno's 15 lines vs AutoGen's 13 lines - similar complexity"
        }
      ]
    },
    {
      "vendor_a": "agno",
      "vendor_b": "atomic-agents",
      "summary": "Agno's 104-line minimalist approach contrasts dramatically with Atomic Agents' 234-line enterprise-grade implementation. This represents the extreme ends of the simplicity vs structure spectrum.",
      "suitability": {
        "agno": "When you need something working quickly with minimal code",
        "atomic-agents": "When building production systems requiring type safety and structure"
      },
      "overall_winner": "Context dependent - agno for prototypes, atomic-agents for production",
      "pros_cons": {
        "agno": {
          "pros": ["Minimal code", "Quick setup", "Easy to understand", "Low overhead"],
          "cons": ["No type safety", "Limited structure", "Basic features", "Less maintainable"]
        },
        "atomic-agents": {
          "pros": ["Full type safety", "Enterprise patterns", "Structured tools", "Maintainable"],
          "cons": ["2.25x more code", "Complex setup", "Heavy boilerplate", "Steep learning curve"]
        }
      },
      "block_mappings": [
        {
          "description": "Type definitions",
          "vendor_a": {"lines": [0, 0], "component": "No types"},
          "vendor_b": {"lines": [34, 123], "component": "Schema classes"},
          "comparison": "Agno has no type definitions vs Atomic's 89 lines of schemas"
        },
        {
          "description": "Tool integration",
          "vendor_a": {"lines": [62, 62], "component": "tools parameter"},
          "vendor_b": {"lines": [66, 123], "component": "Tool class implementations"},
          "comparison": "Agno's 1-line parameter vs Atomic's 57-line tool classes"
        },
        {
          "description": "Agent setup",
          "vendor_a": {"lines": [59, 64], "component": "Agent creation"},
          "vendor_b": {"lines": [156, 196], "component": "TechWriterAgent class"},
          "comparison": "Agno's 5-line setup vs Atomic's 40-line agent class"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "pydantic-ai",
      "summary": "Both modern async implementations take different approaches: LangGraph's 166 lines focus on graph-based workflows, while Pydantic-AI's 136 lines emphasize clean patterns with dependency injection.",
      "suitability": {
        "langgraph": "When you need LangChain ecosystem and graph workflows",
        "pydantic-ai": "When you want clean, testable code with DI patterns"
      },
      "overall_winner": "pydantic-ai for clean code, langgraph for ecosystem",
      "pros_cons": {
        "langgraph": {
          "pros": ["Rich ecosystem", "Graph workflows", "Streaming support", "LangChain integration"],
          "cons": ["More complex", "Heavier dependencies", "Verbose setup", "Framework lock-in"]
        },
        "pydantic-ai": {
          "pros": ["Cleaner patterns", "Dependency injection", "More concise", "Testable"],
          "cons": ["Less ecosystem", "No graph features", "Framework patterns", "Hidden control"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool definition style",
          "vendor_a": {"lines": [63, 96], "component": "Wrapper functions"},
          "vendor_b": {"lines": [37, 66], "component": "Decorated methods"},
          "comparison": "LangGraph's 33-line wrappers vs Pydantic-AI's 29-line decorators"
        },
        {
          "description": "Context handling",
          "vendor_a": {"lines": [74, 74], "component": "Closure binding"},
          "vendor_b": {"lines": [25, 29], "component": "Context class"},
          "comparison": "LangGraph uses closures vs Pydantic-AI's typed context"
        },
        {
          "description": "Agent execution",
          "vendor_a": {"lines": [111, 118], "component": "agent.invoke"},
          "vendor_b": {"lines": [86, 90], "component": "tech_writer.run"},
          "comparison": "LangGraph's 7-line invoke vs Pydantic-AI's 4-line run"
        }
      ]
    },
    {
      "vendor_a": "langgraph",
      "vendor_b": "atomic-agents",
      "summary": "LangGraph's 166-line async graph-based approach contrasts with Atomic Agents' 234-line sync type-safe implementation. Both are production-ready but optimize for different concerns.",
      "suitability": {
        "langgraph": "When you need async and LangChain ecosystem integration",
        "atomic-agents": "When type safety and structured patterns are paramount"
      },
      "overall_winner": "langgraph for modern async apps, atomic-agents for type safety",
      "pros_cons": {
        "langgraph": {
          "pros": ["Async native", "Graph workflows", "LangChain ecosystem", "More concise"],
          "cons": ["Less type safety", "Framework dependency", "Complex setup", "Less structure"]
        },
        "atomic-agents": {
          "pros": ["Full type safety", "Clear structure", "Schema validation", "Enterprise patterns"],
          "cons": ["No async", "More verbose", "Heavy boilerplate", "Complex schemas"]
        }
      },
      "block_mappings": [
        {
          "description": "Type safety approach",
          "vendor_a": {"lines": [0, 0], "component": "No schemas"},
          "vendor_b": {"lines": [34, 123], "component": "Pydantic schemas"},
          "comparison": "LangGraph has no schemas vs Atomic's 89 lines of type definitions"
        },
        {
          "description": "Tool implementation",
          "vendor_a": {"lines": [63, 96], "component": "Function wrappers"},
          "vendor_b": {"lines": [66, 123], "component": "Tool classes"},
          "comparison": "LangGraph's 33-line wrappers vs Atomic's 57-line classes"
        },
        {
          "description": "Async vs sync",
          "vendor_a": {"lines": [36, 123], "component": "Async analyze_codebase"},
          "vendor_b": {"lines": [198, 206], "component": "Sync analyse_codebase"},
          "comparison": "LangGraph's 87-line async vs Atomic's 8-line sync function"
        }
      ]
    },
    {
      "vendor_a": "pydantic-ai",
      "vendor_b": "autogen",
      "summary": "Both clean async implementations are similar in length (136 vs 135 lines) but differ in patterns: Pydantic-AI uses decorators and DI while AutoGen uses straightforward async wrappers.",
      "suitability": {
        "pydantic-ai": "When you want elegant patterns and testability",
        "autogen": "When you prefer simple, direct async code"
      },
      "overall_winner": "pydantic-ai for architecture, autogen for simplicity",
      "pros_cons": {
        "pydantic-ai": {
          "pros": ["Dependency injection", "Decorator elegance", "Testable design", "Clean patterns"],
          "cons": ["Framework conventions", "Hidden control flow", "Learning curve", "More abstraction"]
        },
        "autogen": {
          "pros": ["Direct approach", "Simple async", "Clear flow", "Less magic"],
          "cons": ["Less elegant", "No DI", "Basic patterns", "Less testable"]
        }
      },
      "block_mappings": [
        {
          "description": "Tool definition approach",
          "vendor_a": {"lines": [37, 66], "component": "Decorated tools"},
          "vendor_b": {"lines": [33, 62], "component": "Async wrappers"},
          "comparison": "Both use ~29 lines but different patterns"
        },
        {
          "description": "Context/state management",
          "vendor_a": {"lines": [25, 29], "component": "AnalysisContext"},
          "vendor_b": {"lines": [0, 0], "component": "No explicit context"},
          "comparison": "Pydantic-AI's typed context vs AutoGen's implicit state"
        },
        {
          "description": "Agent pattern",
          "vendor_a": {"lines": [31, 35], "component": "Global agent with DI"},
          "vendor_b": {"lines": [79, 85], "component": "Local agent creation"},
          "comparison": "Pydantic-AI's 4-line global vs AutoGen's 6-line local"
        }
      ]
    },
    {
      "vendor_a": "pydantic-ai",
      "vendor_b": "atomic-agents",
      "summary": "Pydantic-AI's 136-line decorator-based async approach contrasts with Atomic Agents' 234-line schema-heavy sync implementation. Both prioritize clean architecture but through different means.",
      "suitability": {
        "pydantic-ai": "When you want clean async code with minimal boilerplate",
        "atomic-agents": "When you need maximum type safety and structure"
      },
      "overall_winner": "pydantic-ai for elegance, atomic-agents for enterprise",
      "pros_cons": {
        "pydantic-ai": {
          "pros": ["More concise", "Async support", "Clean decorators", "Less boilerplate"],
          "cons": ["Less structured", "Fewer schemas", "Hidden magic", "Less explicit"]
        },
        "atomic-agents": {
          "pros": ["Maximum type safety", "Explicit structure", "Clear patterns", "Schema validation"],
          "cons": ["Very verbose", "No async", "Heavy setup", "Complex inheritance"]
        }
      },
      "block_mappings": [
        {
          "description": "Schema definitions",
          "vendor_a": {"lines": [25, 29], "component": "Single context class"},
          "vendor_b": {"lines": [34, 123], "component": "Multiple schema classes"},
          "comparison": "Pydantic-AI's 4-line context vs Atomic's 89 lines of schemas"
        },
        {
          "description": "Tool implementation",
          "vendor_a": {"lines": [37, 66], "component": "Decorated functions"},
          "vendor_b": {"lines": [66, 123], "component": "Tool classes"},
          "comparison": "Pydantic-AI's 29-line decorators vs Atomic's 57-line classes"
        },
        {
          "description": "Agent setup",
          "vendor_a": {"lines": [31, 35], "component": "Simple agent"},
          "vendor_b": {"lines": [170, 182], "component": "Complex config"},
          "comparison": "Pydantic-AI's 4 lines vs Atomic's 12-line configuration"
        }
      ]
    },
    {
      "vendor_a": "autogen",
      "vendor_b": "atomic-agents",
      "summary": "AutoGen's 135-line minimal async implementation contrasts sharply with Atomic Agents' 234-line type-safe sync approach. AutoGen prioritizes simplicity while Atomic emphasizes structure.",
      "suitability": {
        "autogen": "When you need simple async agents with minimal overhead",
        "atomic-agents": "When building enterprise systems requiring full type safety"
      },
      "overall_winner": "autogen for simplicity, atomic-agents for robustness",
      "pros_cons": {
        "autogen": {
          "pros": ["Async support", "Minimal code", "Direct approach", "Easy to understand"],
          "cons": ["No type safety", "Basic structure", "Limited validation", "Less extensible"]
        },
        "atomic-agents": {
          "pros": ["Full type safety", "Rich schemas", "Enterprise patterns", "Highly structured"],
          "cons": ["No async", "73% more code", "Complex setup", "Steep learning curve"]
        }
      },
      "block_mappings": [
        {
          "description": "Type definitions",
          "vendor_a": {"lines": [0, 0], "component": "No schemas"},
          "vendor_b": {"lines": [34, 123], "component": "Schema classes"},
          "comparison": "AutoGen has no schemas vs Atomic's 89 lines of types"
        },
        {
          "description": "Tool approach",
          "vendor_a": {"lines": [33, 62], "component": "Simple wrappers"},
          "vendor_b": {"lines": [66, 123], "component": "Tool classes"},
          "comparison": "AutoGen's 29-line wrappers vs Atomic's 57-line classes"
        },
        {
          "description": "Agent creation",
          "vendor_a": {"lines": [79, 85], "component": "AssistantAgent"},
          "vendor_b": {"lines": [156, 196], "component": "TechWriterAgent class"},
          "comparison": "AutoGen's 6-line setup vs Atomic's 40-line class"
        }
      ]
    }
  ],
  "metadata": {
    "generated": "2024-12-12",
    "total_implementations": 8,
    "comparison_count": 28,
    "purpose": "Interactive side-by-side comparison of tech writer implementations"
  }
}, null, 2)}
</tech-writer-comparison>

<tone-of-voice-profile>
Skeptical Optimism (Core Dimension):
Description: A foundational tone that approaches claims with healthy skepticism but maintains an underlying optimism about the potential of Vibe Coding and AI agents. It questions hype while looking for genuine value and practical applications.
Application: Critically evaluate tools and success stories, acknowledge limitations and potential pitfalls, but ultimately highlight the empowering aspects and future possibilities in a positive light.

Upbeat & Engaging:
Description: The overall energy should be positive, enthusiastic, and engaging, drawing the reader in rather than presenting information dryly.
Application: Use active voice, varied sentence structure, and a generally positive framing, even when discussing complex or challenging topics.

Truthful & Accurate (Evidence-Based):
Description: All information, especially claims and technical descriptions, must be grounded in verifiable facts and evidence. Avoid making unsubstantiated statements.
Application: Prioritize accuracy in describing tools, technologies, and case studies. Clearly distinguish between established facts, reported claims (with sources), and speculative future trends.

Slightly Sarcastic / Witty Humor:
Description: Incorporate occasional, subtle sarcasm or witty observations to add personality and make the content more relatable and entertaining. The humor should be intelligent and not overly broad or offensive.
Application: Use sparingly in appropriate contexts, perhaps when commenting on industry hype, common misconceptions, or the quirks of technology. It should lighten the tone without undermining credibility.

Analytical & Discerning:
Description: A critical thinking approach that dissects information, compares and contrasts, and doesn't take claims at face value. This aligns with the "skeptical" aspect.
Application: When discussing tools, provide balanced comparisons. When analyzing case studies, look for underlying factors of success or failure, and question the generalizability of results.

Clear & Accessible (Non-Technical Focus):
Description: While the author is knowledgeable, the language must remain accessible to the target audience of non-technical people with business ideas. Avoid jargon where possible, or explain it clearly.
Application: Break down complex concepts into simpler terms. Use analogies or relatable examples. Focus on the implications and value for the reader, not just the technical details.

Direct & Experiential:
Description: The Substack conveys a sense of sharing direct experience and personal insights. The book should echo this by feeling authentic and based on real understanding, even if it's synthesizing broader research.
Application: Frame advice and analysis in a way that feels like it's coming from someone who has navigated this space. Use phrases that suggest firsthand knowledge or deep consideration.

Pragmatic & Action-Oriented:
Description: While analytical, the tone should also be practical, offering readers actionable insights and takeaways they can apply to their own ideas and projects.
Application: Conclude sections or chapters with clear summaries of key lessons or actionable steps. Focus on what the reader can do with the information.

Confident but Humble:
Description: The author's expertise should come through confidently, but without arrogance. Acknowledge the rapidly evolving nature of the field and the possibility of different perspectives.
Application: Present information with conviction where it's well-supported, but be open about areas of uncertainty or ongoing debate.

Conversational & Relatable:
Description: Avoid overly academic or formal language. The tone should feel more like an engaging conversation with a knowledgeable guide.
Application: Use contractions where appropriate. Address the reader directly at times (e.g., "you might find that..."). Incorporate rhetorical questions to stimulate thought.
</tone-of-voice-profile>

Given the tech writer comparison data above, provide incredibly accurate, concise, and to-the-point answers about different Python packages for building tech writer AI agents. Focus on practical recommendations based on the user's specific needs.`;

        // ===== CHAT WIDGET CLASS =====
        class ChatWidget {
            constructor() {
                this.isOpen = false;
                this.isProcessing = false;
                this.conversationHistory = [];
                this.hasSeenWelcome = false;
                
                this.initializeElements();
                this.attachEventListeners();
                this.hideNotificationBadge();
            }

            initializeElements() {
                this.bubble = document.getElementById('chatBubble');
                this.window = document.getElementById('chatWindow');
                this.closeBtn = document.getElementById('chatClose');
                this.messagesContainer = document.getElementById('chatMessages');
                this.input = document.getElementById('chatInput');
                this.sendBtn = document.getElementById('chatSend');
                this.notificationBadge = document.getElementById('notificationBadge');
            }

            attachEventListeners() {
                this.bubble.addEventListener('click', () => this.toggle());
                this.closeBtn.addEventListener('click', () => this.close());
                this.sendBtn.addEventListener('click', () => this.sendMessage());
                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            }

            toggle() {
                this.isOpen ? this.close() : this.open();
            }

            open() {
                this.isOpen = true;
                this.window.classList.add('active');
                this.hideNotificationBadge();
                this.input.focus();
                
                if (!this.hasSeenWelcome) {
                    this.hasSeenWelcome = true;
                    setTimeout(() => {
                        this.addMessage("Hey! I can help you choose the best Python implementation for your tech writer AI agent. With 8 different approaches ranging from 104 to 315 lines, there's definitely a sweet spot for your needs. What matters most to you - simplicity, type safety, async support, or maybe minimal dependencies?", 'assistant');
                    }, 500);
                }
            }

            close() {
                this.isOpen = false;
                this.window.classList.remove('active');
            }

            hideNotificationBadge() {
                this.notificationBadge.style.display = 'none';
            }

            showNotificationBadge() {
                if (!this.isOpen) {
                    this.notificationBadge.style.display = 'flex';
                }
            }

            addMessage(text, role) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = this.formatMessage(text);
                
                messageDiv.appendChild(contentDiv);
                this.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
                
                if (role === 'assistant' && !this.isOpen) {
                    this.showNotificationBadge();
                }
            }

            formatMessage(text) {
                return text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px;">$1</code>')
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n/g, '<br>');
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'message assistant';
                typingDiv.id = 'typingIndicator';
                
                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'typing-indicator';
                indicatorDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                
                typingDiv.appendChild(indicatorDiv);
                this.messagesContainer.appendChild(typingDiv);
                this.scrollToBottom();
            }

            hideTypingIndicator() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            scrollToBottom() {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            async sendMessage() {
                const message = this.input.value.trim();
                if (!message || this.isProcessing) return;

                this.isProcessing = true;
                this.sendBtn.disabled = true;
                
                // Add user message
                this.addMessage(message, 'user');
                this.input.value = '';
                
                // Show typing indicator
                this.showTypingIndicator();

                try {
                    // Build conversation history for Gemini
                    const contents = this.buildContents(message);
                    
                    // Make API request
                    const response = await this.callGeminiAPI(contents);
                    
                    // Hide typing indicator
                    this.hideTypingIndicator();
                    
                    // Add response
                    this.addMessage(response, 'assistant');
                    
                    // Update conversation history
                    this.conversationHistory.push(
                        { role: 'user', content: message },
                        { role: 'assistant', content: response }
                    );
                    
                } catch (error) {
                    this.hideTypingIndicator();
                    this.addMessage(`Sorry, I encountered an error: ${error.message}`, 'assistant');
                    console.error('Chat error:', error);
                } finally {
                    this.isProcessing = false;
                    this.sendBtn.disabled = false;
                    this.input.focus();
                }
            }

            buildContents(currentMessage) {
                const contents = [];
                
                // Add system prompt as first exchange if this is the first message
                if (this.conversationHistory.length === 0) {
                    contents.push({
                        role: "user",
                        parts: [{ text: systemPrompt }]
                    });
                    contents.push({
                        role: "model",
                        parts: [{ text: "I understand. I'm ready to help you choose the best Python package for your AI-powered documentation needs." }]
                    });
                }
                
                // Add conversation history
                this.conversationHistory.forEach(msg => {
                    contents.push({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.content }]
                    });
                });
                
                // Add current message
                contents.push({
                    role: "user",
                    parts: [{ text: currentMessage }]
                });
                
                return contents;
            }

            async callGeminiAPI(contents) {
                const headers = {
                    'Content-Type': 'application/json',
                    'x-goog-api-key': CONFIG.GOOGLE_API_KEY
                };
                
                if (CONFIG.GATEWAY_AUTH_TOKEN) {
                    headers['cf-aig-authorization'] = CONFIG.GATEWAY_AUTH_TOKEN;
                }

                const response = await fetch(GATEWAY_URL, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        contents: contents,
                        generationConfig: {
                            temperature: CONFIG.TEMPERATURE,
                            maxOutputTokens: CONFIG.MAX_TOKENS,
                            topP: 0.8,
                            topK: 10
                        }
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error (${response.status}): ${errorText}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }
        }

        // Initialize chat widget when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            window.chatWidget = new ChatWidget();
        });
    </script>
</body>
</html>