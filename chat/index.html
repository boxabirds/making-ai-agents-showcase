<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Making AI Agents: Tech Writer Agent Comparisons</title>
    
    <!-- REUSE: Phase 1's exact CSS -->
    <style>
        /* Global design tokens only */
        :root {
            --color-bg: #f7f8fa;
            --color-surface: #ffffff;
            --color-border: #e2e8f0;
            --color-text: #1e293b;
            --color-primary: #3b82f6;
            --color-primary-dark: #2563eb;
            
            --header-height: 60px;
            --sidebar-width: 280px;
            --chat-width: 400px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            height: 100vh;
            overflow: hidden;
        }
        
        /* Simple layout grid */
        .app-layout {
            display: grid;
            height: 100vh;
            grid-template-columns: var(--sidebar-width) var(--chat-width) 1fr;
        }
        
        /* Basic containers */
        .sidebar {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: 1rem;
            overflow-y: auto;
        }
        
        .chat-panel {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0; /* Critical for flex scrolling */
        }
        
        /* Input stays at bottom - NOT absolute positioning */
        .chat-panel input-group {
            flex-shrink: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--color-bg);
            border-radius: 0.5rem;
        }
        
        .document-viewer {
            padding: 2rem;
            overflow-y: auto;
            position: relative;
        }
        
        /* Zoom button */
        .zoom-button {
            position: absolute;
            top: 4.5rem;
            right: 1rem;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }
        
        .zoom-button:hover {
            background: var(--color-bg);
            transform: scale(1.05);
        }
        
        .zoom-button svg {
            width: 20px;
            height: 20px;
            color: var(--color-text);
        }
        
        /* Full screen document viewer */
        .document-viewer.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100vh;
            z-index: 1000;
            border-radius: 0;
        }
        
        @media (max-width: 768px) {
            .zoom-button {
                display: none;
            }
        }
        
        /* Mobile layout - EXACTLY from Phase 1 */
        @media (max-width: 768px) {
            .app-layout {
                grid-template-columns: 1fr;
                grid-template-rows: var(--header-height) 1fr;
            }
            
            .mobile-header {
                display: flex;
                align-items: center;
                padding: 1rem;
                background: var(--color-surface);
                border-bottom: 1px solid var(--color-border);
            }
            
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 100;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .chat-panel {
                grid-row: 2;
                height: calc(100vh - var(--header-height));
            }
            
            .document-viewer {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 90vh;
                background: var(--color-surface);
                transform: translateY(100%);
                transition: transform 0.3s ease;
                border-radius: 1rem 1rem 0 0;
                box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
                z-index: 200;
            }
            
            .tray-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 1rem;
                border-bottom: 1px solid var(--color-border);
            }
            
            .tray-title {
                font-size: 1.125rem;
                font-weight: 600;
                color: var(--color-text);
            }
            
            .tray-close {
                width: 32px;
                height: 32px;
                border-radius: 8px;
                background: transparent;
                border: none;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background 0.2s ease;
            }
            
            .tray-close:hover {
                background: var(--color-bg);
            }
            
            .tray-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 199;
                display: none;
            }
            
            body:has(.document-viewer.open) .tray-backdrop {
                display: block;
            }
            
            .sidebar-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 99;
                display: none;
            }
            
            body:has(.sidebar.open) .sidebar-backdrop {
                display: block;
            }
            
            .document-viewer.open {
                transform: translateY(0);
            }
            
            /* When document viewer is open, move the input group to bottom of screen */
            body:has(.document-viewer.open) .chat-panel input-group {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 210;
            }
            
        }
        
        /* Desktop-only */
        @media (min-width: 769px) {
            .mobile-header {
                display: none;
            }
            
            .tray-header {
                display: none;
            }
            
            .tray-backdrop {
                display: none !important;
            }
        }
        
        /* Sidebar improvements */
        .sidebar h2 {
            margin-bottom: 1rem;
            font-size: 1.25rem;
        }
        
        .sidebar-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--color-bg);
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .sidebar-item:hover {
            background: #e2e8f0;
        }
        
        .sidebar-item.active {
            background: var(--color-primary);
            color: white;
        }
        
        .sidebar-item .badge {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 9999px;
        }
        
        .sidebar-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Modern Document Styling */
        .document-viewer {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            color: #1a202c;
            line-height: 1.7;
        }
        
        .document-viewer h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 2rem 0 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #e2e8f0;
            color: #1a202c;
            letter-spacing: -0.025em;
        }
        
        .document-viewer h1:first-child {
            margin-top: 0;
        }
        
        .document-viewer h2 {
            font-size: 1.875rem;
            font-weight: 600;
            margin: 2.5rem 0 1rem;
            color: #2d3748;
            letter-spacing: -0.02em;
        }
        
        .document-viewer h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 2rem 0 0.75rem;
            color: #2d3748;
        }
        
        .document-viewer h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 1.5rem 0 0.5rem;
            color: #4a5568;
        }
        
        .document-viewer p {
            margin-bottom: 1.25rem;
            line-height: 1.75;
            color: #4a5568;
        }
        
        .document-viewer a {
            color: var(--color-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s ease;
            border-bottom: 1px solid transparent;
        }
        
        .document-viewer a:hover {
            color: var(--color-primary-dark);
            border-bottom-color: var(--color-primary);
        }
        
        .document-viewer ul, .document-viewer ol {
            margin: 0 0 1.5rem 0;
            padding-left: 2rem;
            color: #4a5568;
        }
        
        .document-viewer li {
            margin-bottom: 0.5rem;
            line-height: 1.7;
        }
        
        .document-viewer li::marker {
            color: #718096;
        }
        
        .document-viewer blockquote {
            border-left: 4px solid var(--color-primary);
            padding-left: 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: #718096;
            background: #f7fafc;
            padding: 1rem 1.5rem;
            border-radius: 0 0.5rem 0.5rem 0;
        }
        
        .document-viewer code {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            padding: 0.125rem 0.375rem;
            border-radius: 0.375rem;
            font-family: 'SF Mono', Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
            font-size: 0.875em;
            color: #e53e3e;
            font-weight: 500;
        }
        
        .document-viewer pre {
            background: #1a202c;
            padding: 1.5rem;
            border-radius: 0.75rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            position: relative;
        }
        
        .document-viewer pre code {
            background: transparent;
            border: none;
            padding: 0;
            color: #e2e8f0;
            font-size: 0.875rem;
            line-height: 1.7;
            font-weight: 400;
        }
        
        /* Syntax highlighting overrides for dark code blocks */
        .document-viewer pre code.hljs {
            background: transparent;
            color: #e2e8f0;
        }
        
        .document-viewer table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.95rem;
        }
        
        .document-viewer th {
            background: #f7fafc;
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #2d3748;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .document-viewer td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            color: #4a5568;
        }
        
        .document-viewer tr:hover {
            background: #f7fafc;
        }
        
        .document-viewer hr {
            border: none;
            border-top: 2px solid #e2e8f0;
            margin: 2rem 0;
        }
        
        .document-viewer strong {
            font-weight: 600;
            color: #2d3748;
        }
        
        .document-viewer em {
            font-style: italic;
            color: #4a5568;
        }
        
        /* Add some nice transitions for interactive elements */
        .document-viewer * {
            transition: background-color 0.2s ease;
        }
        
        /* Message improvements */
        .message {
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }
        
        .message.user {
            flex-direction: row-reverse;
        }
        
        .message .avatar {
            flex-shrink: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .message.user .avatar {
            background: var(--color-primary);
            color: white;
        }
        
        .message.assistant .avatar {
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        
        .message-content {
            flex: 1;
            background: var(--color-surface);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--color-border);
        }
        
        .message.user .message-content {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        .message.system {
            background: #f0f9ff;
            border-left: 3px solid var(--color-primary);
        }
        
        /* Typing indicator */
        .typing-indicator {
            display: none;
            padding: 1rem;
        }
        
        .typing-indicator.active {
            display: block;
        }
        
        .typing-bubble {
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }
        
        .typing-bubble .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .typing-dots {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            display: flex;
            gap: 0.25rem;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--color-text);
            opacity: 0.4;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        
        /* Artifact Reference (clickable section links) */
        .artifact-reference {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer !important;
            transition: all 0.2s ease;
            max-width: fit-content;
            margin: 0.5rem 0;
            user-select: none;
        }

        .artifact-reference:hover {
            background: #e0f2fe;
            border-color: var(--color-primary);
            transform: translateX(2px);
        }

        .artifact-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .artifact-info {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .artifact-title {
            font-weight: 500;
            color: var(--color-text);
            font-size: 0.875rem;
        }

        .artifact-type {
            font-size: 0.75rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
    </style>
    
    <!-- Load the FIXED component with updateQuickActions() -->
    <script src="./src/components/input-group-component.js?v=fixed"></script>
    
    <!-- Load marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/typescript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/bash.min.js"></script>
    
    <!-- Load AI configuration and label generation -->
    <script>
        // Configuration
        const CONFIG = {
            WORKER_URL: 'https://tech-writer-ai-proxy.julian-harris.workers.dev',
            MODEL: 'gemini-2.0-flash',
            MAX_TOKENS: 1024,
            TEMPERATURE: 0.0
        };

        // Tone profile for tech writer assistant
        const TONE_PROFILE = `TONE OF VOICE PROFILE

Skeptical Optimism (Core Dimension):
Description: A foundational tone that approaches claims with healthy skepticism but maintains an underlying optimism about the potential of Vibe Coding and AI agents. It questions hype while looking for genuine value and practical applications.
Application: Critically evaluate tools and success stories, acknowledge limitations and potential pitfalls, but ultimately highlight the empowering aspects and future possibilities in a positive light.

Upbeat & Engaging:
Description: The overall energy should be positive, enthusiastic, and engaging, drawing the reader in rather than presenting information dryly.
Application: Use active voice, varied sentence structure, and a generally positive framing, even when discussing complex or challenging topics.

Truthful & Accurate (Evidence-Based):
Description: All information, especially claims and technical descriptions, must be grounded in verifiable facts and evidence. Avoid making unsubstantiated statements.
Application: Prioritize accuracy in describing tools, technologies, and case studies. Clearly distinguish between established facts, reported claims (with sources), and speculative future trends.

Slightly Sarcastic / Witty Humor:
Description: Incorporate occasional, subtle sarcasm or witty observations to add personality and make the content more relatable and entertaining.
Application: Use sparingly in appropriate contexts, perhaps when commenting on industry hype, common misconceptions, or the quirks of technology.

Clear & Accessible (Non-Technical Focus):
Description: While knowledgeable, the language must remain accessible to non-technical people with business ideas.
Application: Break down complex concepts into simpler terms. Use analogies or relatable examples.

Conversational & Relatable:
Description: Avoid overly academic or formal language. The tone should feel more like an engaging conversation with a knowledgeable guide.
Application: Use contractions where appropriate. Address the reader directly.`;

        // Build tool definitions for navigation
        function buildToolDefinitions(sections) {
            if (!sections || sections.length === 0) {
                return [];
            }
            
            // Build structured hierarchy
            const sectionStructure = sections.map(s => ({
                name: s.title,
                subsections: s.subsections.map(sub => sub.title)
            }));
            
            // Generate clear description
            const sectionDescriptions = sectionStructure.map(s => {
                if (s.subsections.length > 0) {
                    return `${s.name} (subsections: ${s.subsections.join(', ')})`;
                }
                return s.name;
            }).join('; ');
            
            const sectionNames = sectionStructure.map(s => s.name);
            const allSubsections = sectionStructure.flatMap(s => s.subsections);
            const uniqueSubsections = [...new Set(allSubsections)];
            
            return [{
                function_declarations: [{
                    name: "navigate_to_section",
                    description: `When user asks about content related to these sections, navigate there instead of describing it. Available sections: ${sectionDescriptions}`,
                    parameters: {
                        type: "object",
                        properties: {
                            section: {
                                type: "string",
                                description: "The main section name",
                                enum: sectionNames
                            },
                            subsection: {
                                type: "string",
                                description: "The subsection name within the main section (optional)",
                                enum: uniqueSubsections.length > 0 ? uniqueSubsections : undefined
                            }
                        },
                        required: ["section"]
                    }
                }]
            }];
        }

        // Parse assistant response for tool calls
        function parseAssistantResponse(responseData) {
            if (!responseData.candidates || !responseData.candidates[0] || !responseData.candidates[0].content) {
                console.error('Invalid API response:', responseData);
                throw new Error('API error');
            }
            
            const content = responseData.candidates[0].content;
            
            // Check for function call
            if (content.parts && content.parts[0] && content.parts[0].functionCall) {
                const functionCall = content.parts[0].functionCall;
                return {
                    toolCall: {
                        tool: functionCall.name,
                        section: functionCall.args.section,
                        subsection: functionCall.args.subsection
                    },
                    text: ""
                };
            }
            
            // Regular text response
            if (content.parts && content.parts[0] && content.parts[0].text) {
                return { text: content.parts[0].text };
            }
            
            throw new Error('No valid content in response');
        }

        // Handle tool calls for navigation (FIXED to match working version)
        function handleToolCall(toolCall, sections, app) {
            console.log('Handling tool call:', toolCall);
            
            if (toolCall.tool === 'navigate_to_section') {
                const { section: sectionName, subsection: subsectionName } = toolCall;
                console.log(`Looking for section: "${sectionName}", subsection: "${subsectionName}"`);
                
                // Find matching section by name (case-insensitive)
                const sectionObj = sections.find(
                    s => s.title.toLowerCase() === sectionName.toLowerCase()
                );
                
                if (!sectionObj) {
                    console.error('Section not found:', sectionName);
                    app.addMessage(`I couldn't find the section "${sectionName}". Please check the section name and try again.`, 'assistant');
                    return;
                }
                
                if (subsectionName) {
                    // User wants to navigate to a subsection
                    const subsectionObj = sectionObj.subsections.find(
                        sub => sub.title.toLowerCase() === subsectionName.toLowerCase()
                    );
                    
                    if (subsectionObj) {
                        console.log('Navigating to subsection:', subsectionObj.id, 'in section:', sectionObj.id);
                        app.scrollToElement(subsectionObj.id);
                        app.addArtifactToChat(`Show ${sectionObj.title} > ${subsectionObj.title}`, 'subsection', subsectionObj.id);
                        
                        // Open document viewer on mobile
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                        }
                    } else {
                        // Subsection not found, fallback to main section
                        console.log('Subsection not found, falling back to main section');
                        app.scrollToElement(sectionObj.id);
                        app.addArtifactToChat(`Show ${sectionObj.title}`, 'section', sectionObj.id);
                        app.addMessage(`I couldn't find the subsection "${subsectionName}" in ${sectionName}, so I'm showing the main section.`, 'assistant');
                        
                        // Open document viewer on mobile
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                        }
                    }
                } else {
                    // Navigate to main section only
                    console.log('Navigating to main section:', sectionObj.id);
                    app.scrollToElement(sectionObj.id);
                    app.addArtifactToChat(`Show ${sectionObj.title}`, 'section', sectionObj.id);
                    
                    // Open document viewer on mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('documentViewer').classList.add('open');
                    }
                }
            }
        }

        // Quick Action Label Generation Prompt (from DSPy training)
        const QUICK_ACTION_PROMPT = `Generate short 1-3 word labels for section headings used as quick action buttons.

Examples:
Input: ["Tech Writer Agent in 7 different frameworks", "But first, how many agent maker frameworks are there?", "Why did you pick the tech writer agent for evaluation?"]
Output: ["Overview", "Agent Landscape", "Tech Writer Choice"]

Input: ["What did I learn?", "What did I standardise on?", "How did I rank them?"]
Output: ["Insights", "Shared Code", "Leaderboard"]

Guidelines:
- Keep labels concise (1-3 words maximum)
- Use title case for labels
- Return ONLY a JSON array of strings.

Input: {headings}
Output:`;

        // Generate quick action labels for an array of headings
        window.generateQuickActionLabels = async function generateQuickActionLabels(headings) {
            if (!headings || headings.length === 0) return [];
            
            const prompt = QUICK_ACTION_PROMPT.replace('{headings}', JSON.stringify(headings));
            
            try {
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: CONFIG.MODEL,
                        contents: [
                            { role: "user", parts: [{ text: prompt }] }
                        ],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 256
                        }
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API error');
                }
                
                let content = data.candidates[0].content.parts[0].text.trim();
                
                if (content.startsWith('```json')) {
                    content = content.replace(/^```json\s*\n?/, '').replace(/\n?```\s*$/, '');
                } else if (content.startsWith('```')) {
                    content = content.replace(/^```\s*\n?/, '').replace(/\n?```\s*$/, '');
                }
                
                const labels = JSON.parse(content);
                
                if (labels.length !== headings.length) {
                    throw new Error('Label count mismatch');
                }
                
                console.log('✅ Successfully generated labels using AI:', labels);
                return labels;
            } catch (error) {
                console.error('❌ Failed to generate labels with AI:', error);
                console.warn('⚠️ USING FALLBACK: Simple word extraction');
                
                const fallbackLabels = headings.map(heading => {
                    const words = heading.split(' ').filter(w => 
                        w.length > 2 && !['the', 'and', 'for', 'with', 'from'].includes(w.toLowerCase())
                    );
                    return words.slice(0, 2).join(' ') || heading.slice(0, 20);
                });
                
                console.log('📝 Fallback labels:', fallbackLabels);
                return fallbackLabels;
            }
        }
    </script>
</head>
<body>
    <div class="app-layout">
        <!-- Mobile header -->
        <header class="mobile-header">
            <button onclick="app.toggleSidebar()" style="padding: 0.5rem; background: none; border: none; cursor: pointer; font-size: 2rem;">☰</button>
            <h1 style="margin: 0 auto; font-size: 1.25rem;">Tech Writers Agents in Python</h1>
        </header>
        
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <h2>Python AI Agents</h2>
            <div id="sidebar-sections">
                <!-- Populated dynamically -->
            </div>
        </aside>
        
        <!-- Chat panel -->
        <section class="chat-panel">
            <div class="messages-area" id="messagesArea">
                <div class="message assistant">
                    <div class="avatar">AI</div>
                    <div class="message-content">
                        <a href="https://makingaiagents.substack.com" target="_blank" style="display: block; text-decoration: none; margin-bottom: 0.75rem;">
                            <img src="assets/maia-banner-small.png" alt="Making AI Agents" style="width: 100%; height: auto; border-radius: 8px; cursor: pointer;">
                        </a>
                        Welcome to the Making AI Agents comparison report on tech writer agents.
                    </div>
                </div>
            </div>
            
            <!-- Typing indicator -->
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-bubble">
                    <div class="avatar">AI</div>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            </div>
            
            <!-- FIXED input group component that uses updateQuickActions() -->
            <input-group id="mainInput"></input-group>
        </section>
        
        <!-- Document viewer -->
        <section class="document-viewer" id="documentViewer">
            <div class="tray-header">
                <h3 class="tray-title">Documentation</h3>
                <button class="tray-close" onclick="app.closeTray()" title="Close">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <button class="zoom-button" id="zoomButton" onclick="app.toggleFullscreen()" title="Toggle fullscreen">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            </button>
            <div id="documentContent">
                <!-- Populated dynamically -->
            </div>
        </section>
    </div>
    
    <!-- Tray backdrop for click-to-close -->
    <div class="tray-backdrop" id="trayBackdrop" onclick="app.closeTray()"></div>
    
    <!-- Sidebar backdrop for click-to-close -->
    <div class="sidebar-backdrop" id="sidebarBackdrop" onclick="app.closeSidebar()"></div>
    
    <script type="module">
        import { documentParser } from './src/components/document-parser.js';
        
        // Complete state management (from working script.js)
        const state = {
            currentSection: null,
            currentSubsection: null,
            chatHistory: [],
            documentContent: null,
            conversationHistory: [],
            isProcessing: false
        };

        // Application state and methods
        const app = {
            sections: [],
            currentSection: null,
            mainInput: null,
            
            init() {
                console.log('🎯 FINAL VERSION - App init starting...');
                this.mainInput = document.getElementById('mainInput');
                console.log('Found mainInput element:', this.mainInput);
                
                if (!this.mainInput) {
                    console.error('CRITICAL: mainInput element not found!');
                    return;
                }
                
                // Verify the component has the fixed methods
                if (typeof this.mainInput.updateQuickActions === 'function') {
                    console.log('✅ Component has updateQuickActions method - GOOD!');
                } else {
                    console.error('❌ Component missing updateQuickActions method - OLD VERSION!');
                }
                
                this.setupEventListeners();
                this.setupKeyboardNavigation();
                this.loadDocument().catch(async (err) => {
                    console.error('Document load failed:', err);
                    this.addMessage('System', `Error loading document: ${err.message}`, true);
                    await this.loadSampleDocument();
                });
                
                // Auto-focus chat input after load
                setTimeout(() => {
                    if (this.mainInput && this.mainInput.focus) {
                        this.mainInput.focus();
                    }
                }, 500);
            },
            
            setupKeyboardNavigation() {
                const documentViewer = document.getElementById('documentContent');
                
                // Handle spacebar navigation
                document.addEventListener('keydown', (e) => {
                    // Skip if user is typing in input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (e.code === 'Space') {
                        this.handleSpacebarNavigation(e);
                    }
                });
                
                // Handle arrow key navigation  
                documentViewer.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        this.handleArrowNavigation(e);
                    }
                });
            },

            handleSpacebarNavigation(e) {
                const panel = document.getElementById('documentContent');
                const viewer = document.getElementById('documentViewer');
                const isAtEnd = viewer.scrollHeight - viewer.scrollTop <= viewer.clientHeight + 10;
                const isAtTop = viewer.scrollTop <= 10;
                
                if (e.shiftKey && isAtTop) {
                    // Shift+spacebar at top: Move to previous section
                    e.preventDefault();
                    const currentIndex = this.sections.findIndex(s => s.id === state.currentSection);
                    
                    if (currentIndex > 0) {
                        const prevSection = this.sections[currentIndex - 1];
                        this.selectSection(prevSection.id);
                        
                        // Scroll to bottom of previous section
                        setTimeout(() => {
                            viewer.scrollTop = viewer.scrollHeight;
                        }, 50);
                    }
                } else if (!e.shiftKey && isAtEnd) {
                    // Spacebar at end: Move to next section
                    e.preventDefault();
                    const currentIndex = this.sections.findIndex(s => s.id === state.currentSection);
                    
                    if (currentIndex >= 0 && currentIndex < this.sections.length - 1) {
                        const nextSection = this.sections[currentIndex + 1];
                        this.selectSection(nextSection.id);
                        
                        // Scroll to top of new section
                        setTimeout(() => {
                            viewer.scrollTop = 0;
                        }, 50);
                    }
                }
            },

            handleArrowNavigation(e) {
                const viewer = document.getElementById('documentViewer');
                const isAtEnd = viewer.scrollHeight - viewer.scrollTop <= viewer.clientHeight + 10;
                const isAtTop = viewer.scrollTop <= 10;
                
                if (e.key === 'ArrowUp' && isAtTop) {
                    // Up arrow at top: Move to previous section
                    e.preventDefault();
                    const currentIndex = this.sections.findIndex(s => s.id === state.currentSection);
                    
                    if (currentIndex > 0) {
                        const prevSection = this.sections[currentIndex - 1];
                        this.selectSection(prevSection.id);
                        
                        // Scroll to bottom of previous section
                        setTimeout(() => {
                            viewer.scrollTop = viewer.scrollHeight;
                        }, 50);
                    }
                } else if (e.key === 'ArrowDown' && isAtEnd) {
                    // Down arrow at end: Move to next section
                    e.preventDefault();
                    const currentIndex = this.sections.findIndex(s => s.id === state.currentSection);
                    
                    if (currentIndex >= 0 && currentIndex < this.sections.length - 1) {
                        const nextSection = this.sections[currentIndex + 1];
                        this.selectSection(nextSection.id);
                        
                        // Scroll to top of new section
                        setTimeout(() => {
                            viewer.scrollTop = 0;
                        }, 50);
                    }
                }
            },

            setupEventListeners() {
                console.log('📡 Setting up event listeners...');
                
                if (!this.mainInput) {
                    console.error('mainInput not found!');
                    return;
                }
                
                // Quick action clicks
                this.mainInput.addEventListener('action-click', (e) => {
                    console.log('🔘 Quick action clicked:', e.detail.actionId);
                    
                    // Find the subsection details
                    let subsectionTitle = null;
                    let parentSection = null;
                    
                    for (const section of this.sections) {
                        const subsection = section.subsections.find(sub => sub.id === e.detail.actionId);
                        if (subsection) {
                            subsectionTitle = subsection.title;
                            parentSection = section;
                            break;
                        }
                    }
                    
                    // Add artifact to chat for quick action navigation
                    if (subsectionTitle && parentSection) {
                        this.addArtifactToChat(
                            `${parentSection.title} > ${subsectionTitle}`,
                            'subsection',
                            e.detail.actionId
                        );
                    }
                    
                    // Navigate to the subsection
                    this.navigateToSubsection(e.detail.actionId);
                });
                
                // Message submissions
                this.mainInput.addEventListener('message-submit', (e) => {
                    console.log('✅ Message submit event received:', e.detail.message);
                    this.sendMessage(e.detail.message);
                });
            },
            
            async loadDocument() {
                console.log('📄 loadDocument starting...');
                try {
                    const response = await fetch('report.md');
                    if (!response.ok) {
                        throw new Error('Failed to load report.md');
                    }
                    const markdown = await response.text();
                    
                    // Store document content for system prompt (CRITICAL!)
                    state.documentContent = markdown;
                    
                    this.sections = await documentParser.parseMarkdown(markdown);
                    this.populateSidebar();
                    this.renderDocument();
                    
                    if (this.sections.length > 0) {
                        this.selectSection(this.sections[0].id);
                        
                        // Open document viewer by default on mobile
                        if (window.innerWidth <= 768) {
                            setTimeout(() => {
                                document.getElementById('documentViewer').classList.add('open');
                            }, 100);
                        }
                    }
                    
                    console.log('📄 Document loaded successfully');
                } catch (error) {
                    console.error('❌ loadDocument error:', error);
                    throw error;
                }
            },
            
            populateSidebar() {
                const container = document.getElementById('sidebar-sections');
                container.innerHTML = '';
                
                this.sections.forEach(section => {
                    const div = document.createElement('div');
                    div.className = 'sidebar-item';
                    div.innerHTML = `
                        ${section.title}
                        ${section.bracketedPhrase ? `<span class="badge">${section.bracketedPhrase}</span>` : ''}
                    `;
                    div.onclick = () => {
                        this.selectSection(section.id);
                        
                        // Open document viewer on mobile when selecting from sidebar
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                            
                            // Close sidebar after selection
                            document.getElementById('sidebar').classList.remove('open');
                        }
                    };
                    container.appendChild(div);
                });
            },
            
            renderDocument() {
                const content = document.getElementById('documentContent');
                
                // Configure marked.js for proper code highlighting
                if (typeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true,
                        gfm: true,
                        highlight: function(code, lang) {
                            // If no language specified, try to auto-detect
                            if (!lang) lang = 'plaintext';
                            
                            // Use highlight.js if available
                            if (typeof hljs !== 'undefined') {
                                try {
                                    return hljs.highlight(code, { language: lang }).value;
                                } catch (e) {
                                    return hljs.highlightAuto(code).value;
                                }
                            }
                            return code;
                        }
                    });
                }
                
                content.innerHTML = documentParser.renderFullHTML();
                
                // Make all links in document open in new tab
                content.querySelectorAll('a').forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
                
                // Apply highlight.js to any code blocks that weren't highlighted
                if (typeof hljs !== 'undefined') {
                    content.querySelectorAll('pre code').forEach((block) => {
                        if (!block.classList.contains('hljs')) {
                            hljs.highlightElement(block);
                        }
                    });
                }
            },
            
            selectSection(sectionId) {
                console.log('🎯 selectSection called with:', sectionId);
                const section = this.sections.find(s => s.id === sectionId);
                if (!section) return;
                
                this.currentSection = sectionId;
                
                // Update sidebar active state
                const items = document.querySelectorAll('.sidebar-item');
                this.sections.forEach((s, index) => {
                    items[index]?.classList.toggle('active', s.id === sectionId);
                });
                
                // Check if we need to generate labels first
                const needsLabels = section.subsections.length > 0 && 
                                   section.subsections.some(sub => !sub.label) && 
                                   window.generateQuickActionLabels;
                
                if (needsLabels) {
                    // Clear quick actions while generating labels to prevent flash
                    this.mainInput.quickActions = [];
                    
                    // Generate labels first, then set quick actions
                    this.generateLabelsForSection(section).then(() => {
                        // Now set quick actions with generated labels
                        this.mainInput.quickActions = section.subsections.map(sub => ({
                            id: sub.id,
                            text: sub.label || sub.title
                        }));
                    });
                } else {
                    // Labels already exist, set quick actions immediately
                    this.mainInput.quickActions = section.subsections.map(sub => ({
                        id: sub.id,
                        text: sub.label || sub.title
                    }));
                }
                
                this.scrollToElement(sectionId);
                state.currentSection = sectionId;
            },
            
            // Generate AI labels for a section's subsections (with caching)
            async generateLabelsForSection(section) {
                if (!section.subsections || section.subsections.length === 0) return;
                
                // Check if labels are already cached
                const allHaveLabels = section.subsections.every(sub => sub.label);
                if (allHaveLabels) {
                    console.log('✅ Using cached AI labels for section:', section.title);
                    return;
                }
                
                const headings = section.subsections.map(sub => sub.title);
                
                try {
                    const labels = await window.generateQuickActionLabels(headings);
                    
                    section.subsections.forEach((sub, index) => {
                        if (labels[index]) {
                            sub.label = labels[index];
                        }
                    });
                    
                    // Quick actions are now updated in selectSection after labels are ready
                    console.log('✅ AI labels generated successfully for section:', section.title);
                } catch (error) {
                    console.error('Failed to generate labels for section:', section.title, error);
                }
            },
            
            navigateToSection(sectionId, subsectionId) {
                console.log('🔗 Navigating to section:', sectionId, 'subsection:', subsectionId);
                
                // Find and select the section
                const section = this.sections.find(s => s.id === sectionId);
                if (section) {
                    this.selectSection(sectionId);
                }
                
                // If subsection specified, scroll to it
                if (subsectionId) {
                    setTimeout(() => {
                        this.scrollToElement(subsectionId);
                    }, 100);
                } else {
                    this.scrollToElement(sectionId);
                }
                
                // Open document viewer on mobile
                if (window.innerWidth <= 768) {
                    document.getElementById('documentViewer').classList.add('open');
                }
            },

            navigateToSubsection(subsectionId) {
                console.log('🔗 Navigating to subsection:', subsectionId);
                this.scrollToElement(subsectionId);
                
                if (window.innerWidth <= 768) {
                    document.getElementById('documentViewer').classList.add('open');
                }
            },
            
            scrollToElement(elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    element.style.background = '#e0f2fe';
                    element.style.transition = 'background 0.3s ease';
                    setTimeout(() => {
                        element.style.background = '';
                    }, 1000);
                }
            },
            
            // Complete sendMessage function from working script.js
            async sendMessage(message) {
                if (!message || state.isProcessing) return;
                
                state.isProcessing = true;
                
                // Add user message
                this.addMessage(message, 'user');
                
                // Show typing indicator
                this.showTyping();
                
                // Process message with LLM
                try {
                    const response = await this.processUserMessage(message);
                    this.hideTyping();
                    
                    // Check if response contains tool calls
                    if (response.toolCall) {
                        // Use FIXED handleToolCall that adds artifacts like working version
                        handleToolCall(response.toolCall, this.sections, this);
                        
                        // Update conversation history with tool call
                        state.conversationHistory.push(
                            { role: 'user', content: message }
                        );
                        
                        state.conversationHistory.push({
                            role: 'assistant',
                            content: '',
                            parts: [{
                                functionCall: {
                                    name: response.toolCall.tool,
                                    args: {
                                        section: response.toolCall.section,
                                        subsection: response.toolCall.subsection || ''
                                    }
                                }
                            }]
                        });
                        
                        // Add function response to history  
                        state.conversationHistory.push({
                            role: 'function',
                            parts: [{
                                functionResponse: {
                                    name: response.toolCall.tool,
                                    response: { result: "Navigation completed" }
                                }
                            }]
                        });
                        
                    } else {
                        this.addMessage(response.text, 'assistant');
                        
                        // Update conversation history
                        state.conversationHistory.push(
                            { role: 'user', content: message },
                            { role: 'assistant', content: response.text }
                        );
                        
                        // On mobile, close tray when response doesn't navigate
                        if (window.innerWidth <= 768) {
                            this.closeTray();
                        }
                    }
                } catch (error) {
                    console.error('❌ Chat error:', error);
                    this.hideTyping();
                    
                    // User-friendly error messages
                    let errorMessage = "I apologize, there's a temporary problem with the chat service. Please try again in a moment.";
                    
                    if (error.message.includes('overloaded') || error.message.includes('503')) {
                        errorMessage = "The AI service is currently experiencing high demand. Please try again in a few moments.";
                    } else if (error.message.includes('429')) {
                        errorMessage = "You're sending messages too quickly. Please wait a moment before trying again.";
                    } else if (error.message.includes('network') || error.message.includes('fetch')) {
                        errorMessage = "There seems to be a network connectivity issue. Please check your connection and try again.";
                    }
                    
                    this.addMessage(errorMessage, 'assistant');
                }
                
                state.isProcessing = false;
            },

            // Process user message with complete tool handling
            async processUserMessage(message) {
                const contents = this.buildContents(message);
                const tools = buildToolDefinitions(this.sections);
                
                const requestBody = {
                    model: CONFIG.MODEL,
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 512
                    }
                };
                
                // Add tools if available
                if (tools.length > 0) {
                    requestBody.tools = tools;
                }
                
                console.log('🔧 Making API call with tools:', tools.length > 0 ? 'enabled' : 'disabled');
                
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (data.error) {
                    // Check for specific error types
                    if (data.error.code === 503 || data.error.status === 'UNAVAILABLE') {
                        throw new Error('overloaded');
                    } else if (data.error.code === 429) {
                        throw new Error('429');
                    }
                    throw new Error(data.error.message || 'API error');
                }
                
                // Parse response for tool calls or text
                return parseAssistantResponse(data);
            },

            // Build contents with conversation history
            buildContents(currentMessage) {
                const contents = [];
                
                // Build system prompt
                const systemPrompt = this.buildSystemPrompt();
                
                // Always include system prompt at the beginning
                contents.push({
                    role: "user",
                    parts: [{ text: systemPrompt }]
                });
                contents.push({
                    role: "model", 
                    parts: [{ text: "I understand. I'm ready to help you navigate and understand this document. I can answer questions about its content and help you find specific sections." }]
                });
                
                // Add conversation history
                state.conversationHistory.forEach(msg => {
                    if (msg.role === 'function') {
                        // Function responses use the exact format from history
                        contents.push({
                            role: 'function',
                            parts: msg.parts
                        });
                    } else if (msg.parts) {
                        // Tool calls with parts array
                        contents.push({
                            role: msg.role === 'assistant' ? 'model' : msg.role,
                            parts: msg.parts
                        });
                    } else {
                        // Regular text messages
                        contents.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                });
                
                // Add current message
                contents.push({
                    role: "user",
                    parts: [{ text: currentMessage }]
                });
                
                return contents;
            },

            buildSystemPrompt() {
                let prompt = `You are a helpful AI assistant that helps users navigate and understand the report.
    You respond in a tone of voice profile as defined below. Your answers should be accurate, concise, and helpful.

<report>
${state.documentContent || 'No document loaded yet.'}
</report>

<available-sections>
`;
                
                // Add available sections for navigation (from working script.js)
                if (this.sections) {
                    this.sections.forEach(section => {
                        prompt += `- ${section.title} (id: ${section.id})`;
                        if (section.subsections.length > 0) {
                            prompt += '\n  Subsections:';
                            section.subsections.forEach(sub => {
                                prompt += `\n    - ${sub.title} (id: ${sub.id})`;
                            });
                        }
                        prompt += '\n';
                    });
                }
                
                prompt += `</available-sections>

<tone-profile>
${TONE_PROFILE}
</tone-profile>

Remember: 
- Base your answers on the document content provided above
- Be helpful in navigating the document
- Keep responses concise and relevant
- When users ask about specific topics that are covered in the sections, jump to that section instead of responding with a message`;
                
                return prompt;
            },
            
            buildDocumentContext() {
                if (!this.sections || this.sections.length === 0) {
                    return "No document loaded.";
                }
                
                let context = "Document sections:\\n";
                this.sections.forEach(section => {
                    context += `- ${section.title}`;
                    if (section.subsections.length > 0) {
                        context += ` (${section.subsections.map(sub => sub.title).join(', ')})`;
                    }
                    context += "\\n";
                });
                
                if (this.currentSection) {
                    const section = this.sections.find(s => s.id === this.currentSection);
                    if (section) {
                        context += `\\nCurrently viewing: ${section.title}`;
                    }
                }
                
                return context;
            },
            
            
            showTyping() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.classList.add('active');
                    this.scrollToBottom();
                }
            },
            
            hideTyping() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.classList.remove('active');
                }
            },

            scrollToBottom() {
                const messagesArea = document.getElementById('messagesArea');
                if (messagesArea) {
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
            },

            // Add clickable artifact reference (from working script.js)
            addArtifactToChat(title, type, sectionId) {
                const messagesArea = document.getElementById('messagesArea');
                const artifactDiv = document.createElement('div');
                artifactDiv.className = 'artifact-reference';
                artifactDiv.innerHTML = `
                    <div class="artifact-icon">${type === 'section' ? '📑' : '📄'}</div>
                    <div class="artifact-info">
                        <div class="artifact-title">${title}</div>
                    </div>
                `;
                
                artifactDiv.addEventListener('click', () => {
                    if (type === 'section') {
                        this.navigateToSection(sectionId);
                    } else {
                        // For subsections, find parent section
                        const section = this.sections.find(s => 
                            s.subsections.some(sub => sub.id === sectionId)
                        );
                        if (section) {
                            this.navigateToSection(section.id, sectionId);
                        }
                    }
                });
                
                messagesArea.appendChild(artifactDiv);
                this.scrollToBottom();
            },
            
            addMessage(content, sender) {
                const messagesArea = document.getElementById('messagesArea');
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}`;
                
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.textContent = sender === 'user' ? 'You' : 'AI';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                if (sender === 'assistant') {
                    // Parse markdown in assistant messages
                    let html = marked.parse(content);
                    
                    // Make all links open in new tab
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    tempDiv.querySelectorAll('a').forEach(link => {
                        link.setAttribute('target', '_blank');
                        link.setAttribute('rel', 'noopener noreferrer');
                    });
                    contentDiv.innerHTML = tempDiv.innerHTML;
                } else {
                    contentDiv.textContent = content;
                }
                
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);
                
                // Remove welcome message if exists
                const welcomeMsg = messagesArea.querySelector('.message:first-child');
                if (welcomeMsg && welcomeMsg.querySelector('.message-content')?.textContent.includes('Welcome!')) {
                    welcomeMsg.remove();
                }
                
                messagesArea.appendChild(messageDiv);
                this.scrollToBottom();
            },
            
            async loadSampleDocument() {
                const fallbackMarkdown = `# Tech Writer Agent Demo [Fallback]

Couldn't load report.md - using sample content.

## Sample Section

This is a demonstration of the document parser.

## Another Section

Quick actions will be generated from these H2 headings.`;
                
                // Store document content for system prompt (CRITICAL!)
                state.documentContent = fallbackMarkdown;
                
                this.sections = await documentParser.parseMarkdown(fallbackMarkdown);
                this.populateSidebar();
                this.renderDocument();
                if (this.sections.length > 0) {
                    this.selectSection(this.sections[0].id);
                }
            },
            
            // Mobile functions
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('open');
            },
            
            closeSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('open');
                // Focus back on chat input
                setTimeout(() => {
                    if (this.mainInput && this.mainInput.focus) {
                        this.mainInput.focus();
                    }
                }, 300);
            },
            
            closeAll() {
                document.getElementById('sidebar').classList.remove('open');
                this.closeTray();
            },
            
            closeTray() {
                const viewer = document.getElementById('documentViewer');
                if (viewer.classList.contains('open')) {
                    viewer.classList.remove('open');
                    // Focus back on chat input
                    setTimeout(() => {
                        if (this.mainInput && this.mainInput.focus) {
                            this.mainInput.focus();
                        }
                    }, 300);
                }
            },
            
            toggleFullscreen() {
                const viewer = document.getElementById('documentViewer');
                const button = document.getElementById('zoomButton');
                const isFullscreen = viewer.classList.contains('fullscreen');
                
                if (isFullscreen) {
                    viewer.classList.remove('fullscreen');
                    button.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                        </svg>
                    `;
                } else {
                    viewer.classList.add('fullscreen');
                    button.innerHTML = `
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/>
                        </svg>
                    `;
                }
            }
        };
        
        // Make app methods available globally for onclick handlers
        window.app = app;
        
        // Global error handlers
        window.addEventListener('error', (e) => {
            console.error('💥 Global error:', e.error, e.message, e.filename, e.lineno);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('💥 Unhandled promise rejection:', e.reason);
        });
        
        // Global form prevention
        document.addEventListener('submit', (e) => {
            console.log('🛑 Form submit prevented');
            e.preventDefault();
            e.stopPropagation();
            return false;
        });
        
        // Page refresh detection
        window.addEventListener('beforeunload', (e) => {
            console.warn('🚨 Page refresh detected!');
        });
        
        // Initialize when ready
        customElements.whenDefined('input-group').then(() => {
            console.log('✅ input-group component is ready');
            app.init();
        });
    </script>
</body>
</html>