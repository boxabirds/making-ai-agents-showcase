<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 6 - FINAL WORKING Version</title>
    
    <!-- REUSE: Phase 1's exact CSS -->
    <style>
        /* Global design tokens only */
        :root {
            --color-bg: #f7f8fa;
            --color-surface: #ffffff;
            --color-border: #e2e8f0;
            --color-text: #1e293b;
            --color-primary: #3b82f6;
            --color-primary-dark: #2563eb;
            
            --header-height: 60px;
            --sidebar-width: 280px;
            --chat-width: 400px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            height: 100vh;
            overflow: hidden;
        }
        
        /* Simple layout grid */
        .app-layout {
            display: grid;
            height: 100vh;
            grid-template-columns: var(--sidebar-width) var(--chat-width) 1fr;
        }
        
        /* Basic containers */
        .sidebar {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: 1rem;
            overflow-y: auto;
        }
        
        .chat-panel {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0; /* Critical for flex scrolling */
        }
        
        /* Input stays at bottom - NOT absolute positioning */
        .chat-panel input-group {
            flex-shrink: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--color-bg);
            border-radius: 0.5rem;
        }
        
        .document-viewer {
            padding: 2rem;
            overflow-y: auto;
        }
        
        /* Mobile layout - EXACTLY from Phase 1 */
        @media (max-width: 768px) {
            .app-layout {
                grid-template-columns: 1fr;
                grid-template-rows: var(--header-height) 1fr;
            }
            
            .mobile-header {
                display: flex;
                align-items: center;
                padding: 1rem;
                background: var(--color-surface);
                border-bottom: 1px solid var(--color-border);
            }
            
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 100;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .chat-panel {
                grid-row: 2;
                height: calc(100vh - var(--header-height));
            }
            
            .document-viewer {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 75vh;
                background: var(--color-surface);
                transform: translateY(100%);
                transition: transform 0.3s ease;
                border-radius: 1rem 1rem 0 0;
                box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
                z-index: 90;
            }
            
            .document-viewer.open {
                transform: translateY(0);
            }
            
            /* When document viewer is open, move the input group to bottom of screen */
            body:has(.document-viewer.open) .chat-panel input-group {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 95;
            }
            
            .overlay {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
                z-index: 85;
            }
            
            .overlay.active {
                opacity: 1;
                pointer-events: auto;
            }
        }
        
        /* Desktop-only */
        @media (min-width: 769px) {
            .mobile-header {
                display: none;
            }
            
            .overlay {
                display: none;
            }
        }
        
        /* Sidebar improvements */
        .sidebar h2 {
            margin-bottom: 1rem;
            font-size: 1.25rem;
        }
        
        .sidebar-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--color-bg);
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .sidebar-item:hover {
            background: #e2e8f0;
        }
        
        .sidebar-item.active {
            background: var(--color-primary);
            color: white;
        }
        
        .sidebar-item .badge {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 9999px;
        }
        
        .sidebar-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Document improvements */
        .document-viewer h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--color-border);
        }
        
        .document-viewer h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
            color: var(--color-primary);
        }
        
        .document-viewer p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .document-viewer code {
            background: var(--color-bg);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.875em;
        }
        
        .document-viewer pre {
            background: var(--color-bg);
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        
        /* Message improvements */
        .message strong {
            color: var(--color-primary);
        }
        
        .message.system {
            background: #f0f9ff;
            border-left: 3px solid var(--color-primary);
        }
    </style>
    
    <!-- Load the FIXED component with updateQuickActions() -->
    <script src="input-group-component.js?v=fixed"></script>
    
    <!-- Load marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Load AI configuration and label generation -->
    <script>
        // Configuration
        const CONFIG = {
            WORKER_URL: 'https://tech-writer-ai-proxy.julian-harris.workers.dev',
            MODEL: 'gemini-2.0-flash',
            MAX_TOKENS: 1024,
            TEMPERATURE: 0.0
        };

        // Tone profile for tech writer assistant
        const TONE_PROFILE = `TONE OF VOICE PROFILE

Skeptical Optimism (Core Dimension):
Description: A foundational tone that approaches claims with healthy skepticism but maintains an underlying optimism about the potential of Vibe Coding and AI agents. It questions hype while looking for genuine value and practical applications.
Application: Critically evaluate tools and success stories, acknowledge limitations and potential pitfalls, but ultimately highlight the empowering aspects and future possibilities in a positive light.

Upbeat & Engaging:
Description: The overall energy should be positive, enthusiastic, and engaging, drawing the reader in rather than presenting information dryly.
Application: Use active voice, varied sentence structure, and a generally positive framing, even when discussing complex or challenging topics.

Truthful & Accurate (Evidence-Based):
Description: All information, especially claims and technical descriptions, must be grounded in verifiable facts and evidence. Avoid making unsubstantiated statements.
Application: Prioritize accuracy in describing tools, technologies, and case studies. Clearly distinguish between established facts, reported claims (with sources), and speculative future trends.

Slightly Sarcastic / Witty Humor:
Description: Incorporate occasional, subtle sarcasm or witty observations to add personality and make the content more relatable and entertaining.
Application: Use sparingly in appropriate contexts, perhaps when commenting on industry hype, common misconceptions, or the quirks of technology.

Clear & Accessible (Non-Technical Focus):
Description: While knowledgeable, the language must remain accessible to non-technical people with business ideas.
Application: Break down complex concepts into simpler terms. Use analogies or relatable examples.

Conversational & Relatable:
Description: Avoid overly academic or formal language. The tone should feel more like an engaging conversation with a knowledgeable guide.
Application: Use contractions where appropriate. Address the reader directly.`;

        // Build tool definitions for navigation
        function buildToolDefinitions(sections) {
            if (!sections || sections.length === 0) {
                return [];
            }
            
            // Build structured hierarchy
            const sectionStructure = sections.map(s => ({
                name: s.title,
                subsections: s.subsections.map(sub => sub.title)
            }));
            
            // Generate clear description
            const sectionDescriptions = sectionStructure.map(s => {
                if (s.subsections.length > 0) {
                    return `${s.name} (subsections: ${s.subsections.join(', ')})`;
                }
                return s.name;
            }).join('; ');
            
            const sectionNames = sectionStructure.map(s => s.name);
            const allSubsections = sectionStructure.flatMap(s => s.subsections);
            const uniqueSubsections = [...new Set(allSubsections)];
            
            return [{
                function_declarations: [{
                    name: "navigate_to_section",
                    description: `When user asks about content related to these sections, navigate there instead of describing it. Available sections: ${sectionDescriptions}`,
                    parameters: {
                        type: "object",
                        properties: {
                            section: {
                                type: "string",
                                description: "The main section name",
                                enum: sectionNames
                            },
                            subsection: {
                                type: "string",
                                description: "The subsection name within the main section (optional)",
                                enum: uniqueSubsections.length > 0 ? uniqueSubsections : undefined
                            }
                        },
                        required: ["section"]
                    }
                }]
            }];
        }

        // Parse assistant response for tool calls
        function parseAssistantResponse(responseData) {
            if (!responseData.candidates || !responseData.candidates[0] || !responseData.candidates[0].content) {
                throw new Error('Invalid response format from AI model');
            }
            
            const content = responseData.candidates[0].content;
            
            // Check for function call
            if (content.parts && content.parts[0] && content.parts[0].functionCall) {
                const functionCall = content.parts[0].functionCall;
                return {
                    toolCall: {
                        tool: functionCall.name,
                        section: functionCall.args.section,
                        subsection: functionCall.args.subsection
                    },
                    text: ""
                };
            }
            
            // Regular text response
            if (content.parts && content.parts[0] && content.parts[0].text) {
                return { text: content.parts[0].text };
            }
            
            throw new Error('No valid content in response');
        }

        // Handle tool calls for navigation
        function handleToolCall(toolCall, sections, navigationCallback) {
            if (toolCall.tool === 'navigate_to_section') {
                const { section: sectionName, subsection: subsectionName } = toolCall;
                
                // Find matching section
                const sectionObj = sections.find(
                    s => s.title.toLowerCase() === sectionName.toLowerCase()
                );
                
                if (!sectionObj) {
                    console.error('Section not found:', sectionName);
                    return `I couldn't find the section "${sectionName}". Available sections are: ${sections.map(s => s.title).join(', ')}`;
                }
                
                // Handle subsection navigation
                if (subsectionName) {
                    const subsectionObj = sectionObj.subsections.find(
                        sub => sub.title.toLowerCase() === subsectionName.toLowerCase()
                    );
                    
                    if (subsectionObj) {
                        navigationCallback(subsectionObj.id);
                        return `Navigated to "${subsectionName}" in the "${sectionName}" section.`;
                    } else {
                        navigationCallback(sectionObj.id);
                        return `I found the "${sectionName}" section, but couldn't locate the specific subsection "${subsectionName}". Showing the main section instead.`;
                    }
                } else {
                    navigationCallback(sectionObj.id);
                    return `Navigated to the "${sectionName}" section.`;
                }
            }
            
            return `Unknown tool call: ${toolCall.tool}`;
        }

        // Quick Action Label Generation Prompt (from DSPy training)
        const QUICK_ACTION_PROMPT = `Generate short 1-3 word labels for section headings used as quick action buttons.

Examples:
Input: ["Tech Writer Agent in 7 different frameworks", "But first, how many agent maker frameworks are there?", "Why did you pick the tech writer agent for evaluation?"]
Output: ["Overview", "Agent Landscape", "Tech Writer Choice"]

Input: ["What did I learn?", "What did I standardise on?", "How did I rank them?"]
Output: ["Insights", "Shared Code", "Leaderboard"]

Guidelines:
- Keep labels concise (1-3 words maximum)
- Use title case for labels
- Return ONLY a JSON array of strings.

Input: {headings}
Output:`;

        // Generate quick action labels for an array of headings
        window.generateQuickActionLabels = async function generateQuickActionLabels(headings) {
            if (!headings || headings.length === 0) return [];
            
            const prompt = QUICK_ACTION_PROMPT.replace('{headings}', JSON.stringify(headings));
            
            try {
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: CONFIG.MODEL,
                        contents: [
                            { role: "user", parts: [{ text: prompt }] }
                        ],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 256
                        }
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API error');
                }
                
                let content = data.candidates[0].content.parts[0].text.trim();
                
                if (content.startsWith('```json')) {
                    content = content.replace(/^```json\s*\n?/, '').replace(/\n?```\s*$/, '');
                } else if (content.startsWith('```')) {
                    content = content.replace(/^```\s*\n?/, '').replace(/\n?```\s*$/, '');
                }
                
                const labels = JSON.parse(content);
                
                if (labels.length !== headings.length) {
                    throw new Error('Label count mismatch');
                }
                
                console.log('‚úÖ Successfully generated labels using AI:', labels);
                return labels;
            } catch (error) {
                console.error('‚ùå Failed to generate labels with AI:', error);
                console.warn('‚ö†Ô∏è USING FALLBACK: Simple word extraction');
                
                const fallbackLabels = headings.map(heading => {
                    const words = heading.split(' ').filter(w => 
                        w.length > 2 && !['the', 'and', 'for', 'with', 'from'].includes(w.toLowerCase())
                    );
                    return words.slice(0, 2).join(' ') || heading.slice(0, 20);
                });
                
                console.log('üìù Fallback labels:', fallbackLabels);
                return fallbackLabels;
            }
        }
    </script>
</head>
<body>
    <div class="app-layout">
        <!-- Mobile header -->
        <header class="mobile-header">
            <button onclick="app.toggleSidebar()" style="padding: 0.5rem; background: none; border: none; cursor: pointer;">‚ò∞</button>
            <h1 style="margin: 0 auto; font-size: 1.25rem;">Document Chat</h1>
        </header>
        
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <h2>Documentation</h2>
            <div id="sidebar-sections">
                <!-- Populated dynamically -->
            </div>
        </aside>
        
        <!-- Chat panel -->
        <section class="chat-panel">
            <div class="messages-area" id="messagesArea">
                <div class="message">
                    <strong>Assistant:</strong> Welcome! This is the FINAL WORKING version with the fixed component. Both chat and quick actions should work perfectly.
                </div>
            </div>
            
            <!-- FIXED input group component that uses updateQuickActions() -->
            <input-group id="mainInput"></input-group>
        </section>
        
        <!-- Document viewer -->
        <section class="document-viewer" id="documentViewer">
            <div id="documentContent">
                <!-- Populated dynamically -->
            </div>
        </section>
    </div>
    
    <!-- Mobile overlay -->
    <div class="overlay" id="overlay" onclick="app.closeAll()"></div>
    
    <script type="module">
        import { documentParser } from './src/components/document-parser.js';
        import { state } from './src/state-manager.js';
        
        // Application state and methods
        const app = {
            sections: [],
            currentSection: null,
            mainInput: null,
            
            init() {
                console.log('üéØ FINAL VERSION - App init starting...');
                this.mainInput = document.getElementById('mainInput');
                console.log('Found mainInput element:', this.mainInput);
                
                if (!this.mainInput) {
                    console.error('CRITICAL: mainInput element not found!');
                    return;
                }
                
                // Verify the component has the fixed methods
                if (typeof this.mainInput.updateQuickActions === 'function') {
                    console.log('‚úÖ Component has updateQuickActions method - GOOD!');
                } else {
                    console.error('‚ùå Component missing updateQuickActions method - OLD VERSION!');
                }
                
                this.setupEventListeners();
                this.loadDocument().catch(async (err) => {
                    console.error('Document load failed:', err);
                    this.addMessage('System', `Error loading document: ${err.message}`, true);
                    await this.loadSampleDocument();
                });
            },
            
            setupEventListeners() {
                console.log('üì° Setting up event listeners...');
                
                if (!this.mainInput) {
                    console.error('mainInput not found!');
                    return;
                }
                
                // Quick action clicks
                this.mainInput.addEventListener('action-click', (e) => {
                    console.log('üîò Quick action clicked:', e.detail.actionId);
                    this.navigateToSubsection(e.detail.actionId);
                });
                
                // Message submissions
                this.mainInput.addEventListener('message-submit', (e) => {
                    console.log('‚úÖ Message submit event received:', e.detail.message);
                    this.addMessage('You', e.detail.message);
                    this.handleUserMessage(e.detail.message);
                });
            },
            
            async loadDocument() {
                console.log('üìÑ loadDocument starting...');
                try {
                    const response = await fetch('report.md');
                    if (!response.ok) {
                        throw new Error('Failed to load report.md');
                    }
                    const markdown = await response.text();
                    
                    this.sections = await documentParser.parseMarkdown(markdown);
                    this.populateSidebar();
                    this.renderDocument();
                    
                    if (this.sections.length > 0) {
                        this.selectSection(this.sections[0].id);
                    }
                    
                    console.log('üìÑ Document loaded successfully');
                    
                } catch (error) {
                    console.error('‚ùå loadDocument error:', error);
                    throw error;
                }
            },
            
            populateSidebar() {
                const container = document.getElementById('sidebar-sections');
                container.innerHTML = '';
                
                this.sections.forEach(section => {
                    const div = document.createElement('div');
                    div.className = 'sidebar-item';
                    div.innerHTML = `
                        ${section.title}
                        ${section.bracketedPhrase ? `<span class="badge">${section.bracketedPhrase}</span>` : ''}
                    `;
                    div.onclick = () => this.selectSection(section.id);
                    container.appendChild(div);
                });
            },
            
            renderDocument() {
                const content = document.getElementById('documentContent');
                content.innerHTML = documentParser.renderFullHTML();
            },
            
            selectSection(sectionId) {
                console.log('üéØ selectSection called with:', sectionId);
                const section = this.sections.find(s => s.id === sectionId);
                if (!section) return;
                
                this.currentSection = sectionId;
                
                // Update sidebar active state
                const items = document.querySelectorAll('.sidebar-item');
                this.sections.forEach((s, index) => {
                    items[index]?.classList.toggle('active', s.id === sectionId);
                });
                
                // CRITICAL: Update quick actions using FIXED component
                console.log('üîÑ Setting quick actions using FIXED component...');
                console.log('Component updateQuickActions method exists?', typeof this.mainInput.updateQuickActions);
                
                this.mainInput.quickActions = section.subsections.map(sub => ({
                    id: sub.id,
                    text: sub.label || sub.title
                }));
                
                console.log('‚úÖ Quick actions set successfully without render()!');
                
                // Generate AI labels for quick actions if not already done
                if (section.subsections.length > 0 && !section.subsections[0].label && window.generateQuickActionLabels) {
                    this.generateLabelsForSection(section);
                }
                
                this.scrollToElement(sectionId);
                state.set({ currentSection: sectionId });
            },
            
            // Generate AI labels for a section's subsections
            async generateLabelsForSection(section) {
                if (!section.subsections || section.subsections.length === 0) return;
                
                const headings = section.subsections.map(sub => sub.title);
                
                try {
                    const labels = await window.generateQuickActionLabels(headings);
                    
                    section.subsections.forEach((sub, index) => {
                        if (labels[index]) {
                            sub.label = labels[index];
                        }
                    });
                    
                    if (this.currentSection === section.id) {
                        console.log('üîÑ Updating quick actions with AI labels using FIXED component...');
                        this.mainInput.quickActions = section.subsections.map(sub => ({
                            id: sub.id,
                            text: sub.label || sub.title
                        }));
                        console.log('‚úÖ Quick actions updated with AI labels successfully!');
                    }
                } catch (error) {
                    console.error('Failed to generate labels for section:', section.title, error);
                }
            },
            
            navigateToSubsection(subsectionId) {
                console.log('üîó Navigating to subsection:', subsectionId);
                this.scrollToElement(subsectionId);
                
                if (window.innerWidth <= 768) {
                    document.getElementById('documentViewer').classList.add('open');
                    document.getElementById('overlay').classList.add('active');
                }
            },
            
            scrollToElement(elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    element.style.background = '#e0f2fe';
                    element.style.transition = 'background 0.3s ease';
                    setTimeout(() => {
                        element.style.background = '';
                    }, 1000);
                }
            },
            
            async handleUserMessage(message) {
                console.log('üöÄ handleUserMessage called with:', message);
                
                this.showTyping();
                
                try {
                    const context = this.buildDocumentContext();
                    const prompt = this.buildChatPrompt(message, context);
                    const response = await this.callGeminiChat(prompt);
                    
                    this.hideTyping();
                    this.addMessage('Assistant', response);
                    
                } catch (error) {
                    console.error('‚ùå Chat error:', error);
                    this.hideTyping();
                    this.addMessage('Assistant', `I apologize, but I encountered an error: ${error.message}`);
                }
            },
            
            buildDocumentContext() {
                if (!this.sections || this.sections.length === 0) {
                    return "No document loaded.";
                }
                
                let context = "Document sections:\\n";
                this.sections.forEach(section => {
                    context += `- ${section.title}`;
                    if (section.subsections.length > 0) {
                        context += ` (${section.subsections.map(sub => sub.title).join(', ')})`;
                    }
                    context += "\\n";
                });
                
                if (this.currentSection) {
                    const section = this.sections.find(s => s.id === this.currentSection);
                    if (section) {
                        context += `\\nCurrently viewing: ${section.title}`;
                    }
                }
                
                return context;
            },
            
            buildChatPrompt(userMessage, documentContext) {
                return `You are a technical writing assistant specializing in AI agent frameworks and development tools.

${TONE_PROFILE}

DOCUMENT CONTEXT:
${documentContext}

When users ask about specific sections or topics covered in the documentation, use the navigate_to_section tool to take them directly to the relevant content instead of just describing it.

User question: ${userMessage}

Respond in the tone profile above - be skeptically optimistic, engaging, and conversational while providing accurate, helpful information.`;
            },
            
            async callGeminiChat(prompt) {
                const tools = buildToolDefinitions(this.sections);
                
                const requestBody = {
                    model: CONFIG.MODEL,
                    contents: [
                        { role: "user", parts: [{ text: prompt }] }
                    ],
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 512
                    }
                };
                
                // Add tools if available
                if (tools.length > 0) {
                    requestBody.tools = tools;
                }
                
                console.log('üîß Making API call with tools:', tools.length > 0 ? 'enabled' : 'disabled');
                
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API error');
                }
                
                // Parse response for tool calls or text
                const parsed = parseAssistantResponse(data);
                
                if (parsed.toolCall) {
                    console.log('üîß Tool call detected:', parsed.toolCall);
                    const toolResult = handleToolCall(parsed.toolCall, this.sections, (elementId) => {
                        this.scrollToElement(elementId);
                        // Open document viewer on mobile
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                            document.getElementById('overlay').classList.add('active');
                        }
                    });
                    return toolResult;
                }
                
                return parsed.text.trim();
            },
            
            showTyping() {
                const messagesArea = document.getElementById('messagesArea');
                const typing = document.createElement('div');
                typing.className = 'message typing-indicator';
                typing.id = 'typing-message';
                typing.innerHTML = '<strong>Assistant:</strong> <span class="dots">...</span>';
                messagesArea.appendChild(typing);
                messagesArea.scrollTop = messagesArea.scrollHeight;
            },
            
            hideTyping() {
                const typing = document.getElementById('typing-message');
                if (typing) {
                    typing.remove();
                }
            },
            
            addMessage(sender, text, isSystem = false) {
                const messagesArea = document.getElementById('messagesArea');
                const message = document.createElement('div');
                message.className = 'message' + (isSystem ? ' system' : '');
                message.innerHTML = `<strong>${sender}:</strong> ${text}`;
                messagesArea.appendChild(message);
                messagesArea.scrollTop = messagesArea.scrollHeight;
            },
            
            async loadSampleDocument() {
                const fallbackMarkdown = `# Tech Writer Agent Demo [Fallback]

Couldn't load report.md - using sample content.

## Sample Section

This is a demonstration of the document parser.

## Another Section

Quick actions will be generated from these H2 headings.`;
                
                this.sections = await documentParser.parseMarkdown(fallbackMarkdown);
                this.populateSidebar();
                this.renderDocument();
                if (this.sections.length > 0) {
                    this.selectSection(this.sections[0].id);
                }
            },
            
            // Mobile functions
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('overlay');
                sidebar.classList.toggle('open');
                overlay.classList.toggle('active');
            },
            
            closeAll() {
                document.getElementById('sidebar').classList.remove('open');
                document.getElementById('documentViewer').classList.remove('open');
                document.getElementById('overlay').classList.remove('active');
            }
        };
        
        // Make app methods available globally for onclick handlers
        window.app = app;
        
        // Global error handlers
        window.addEventListener('error', (e) => {
            console.error('üí• Global error:', e.error, e.message, e.filename, e.lineno);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('üí• Unhandled promise rejection:', e.reason);
        });
        
        // Global form prevention
        document.addEventListener('submit', (e) => {
            console.log('üõë Form submit prevented');
            e.preventDefault();
            e.stopPropagation();
            return false;
        });
        
        // Page refresh detection
        window.addEventListener('beforeunload', (e) => {
            console.warn('üö® Page refresh detected!');
        });
        
        // Initialize when ready
        customElements.whenDefined('input-group').then(() => {
            console.log('‚úÖ input-group component is ready');
            app.init();
        });
    </script>
</body>
</html>