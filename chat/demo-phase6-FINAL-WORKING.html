<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase 6 - FINAL WORKING Version</title>
    
    <!-- REUSE: Phase 1's exact CSS -->
    <style>
        /* Global design tokens only */
        :root {
            --color-bg: #f7f8fa;
            --color-surface: #ffffff;
            --color-border: #e2e8f0;
            --color-text: #1e293b;
            --color-primary: #3b82f6;
            --color-primary-dark: #2563eb;
            
            --header-height: 60px;
            --sidebar-width: 280px;
            --chat-width: 400px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            height: 100vh;
            overflow: hidden;
        }
        
        /* Simple layout grid */
        .app-layout {
            display: grid;
            height: 100vh;
            grid-template-columns: var(--sidebar-width) var(--chat-width) 1fr;
        }
        
        /* Basic containers */
        .sidebar {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            padding: 1rem;
            overflow-y: auto;
        }
        
        .chat-panel {
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0; /* Critical for flex scrolling */
        }
        
        /* Input stays at bottom - NOT absolute positioning */
        .chat-panel input-group {
            flex-shrink: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--color-bg);
            border-radius: 0.5rem;
        }
        
        .document-viewer {
            padding: 2rem;
            overflow-y: auto;
        }
        
        /* Mobile layout - EXACTLY from Phase 1 */
        @media (max-width: 768px) {
            .app-layout {
                grid-template-columns: 1fr;
                grid-template-rows: var(--header-height) 1fr;
            }
            
            .mobile-header {
                display: flex;
                align-items: center;
                padding: 1rem;
                background: var(--color-surface);
                border-bottom: 1px solid var(--color-border);
            }
            
            .sidebar {
                position: fixed;
                left: 0;
                top: 0;
                bottom: 0;
                width: var(--sidebar-width);
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 100;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .chat-panel {
                grid-row: 2;
                height: calc(100vh - var(--header-height));
            }
            
            .document-viewer {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 75vh;
                background: var(--color-surface);
                transform: translateY(100%);
                transition: transform 0.3s ease;
                border-radius: 1rem 1rem 0 0;
                box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
                z-index: 90;
            }
            
            .document-viewer.open {
                transform: translateY(0);
            }
            
            /* When document viewer is open, move the input group to bottom of screen */
            body:has(.document-viewer.open) .chat-panel input-group {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 95;
            }
            
            .overlay {
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s ease;
                z-index: 85;
            }
            
            .overlay.active {
                opacity: 1;
                pointer-events: auto;
            }
        }
        
        /* Desktop-only */
        @media (min-width: 769px) {
            .mobile-header {
                display: none;
            }
            
            .overlay {
                display: none;
            }
        }
        
        /* Sidebar improvements */
        .sidebar h2 {
            margin-bottom: 1rem;
            font-size: 1.25rem;
        }
        
        .sidebar-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--color-bg);
            border-radius: 0.375rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .sidebar-item:hover {
            background: #e2e8f0;
        }
        
        .sidebar-item.active {
            background: var(--color-primary);
            color: white;
        }
        
        .sidebar-item .badge {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 9999px;
        }
        
        .sidebar-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Document improvements */
        .document-viewer h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--color-border);
        }
        
        .document-viewer h2 {
            font-size: 1.5rem;
            margin: 2rem 0 1rem;
            color: var(--color-primary);
        }
        
        .document-viewer p {
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .document-viewer code {
            background: var(--color-bg);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.875em;
        }
        
        .document-viewer pre {
            background: var(--color-bg);
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        
        /* Message improvements */
        .message {
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }
        
        .message.user {
            flex-direction: row-reverse;
        }
        
        .message .avatar {
            flex-shrink: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .message.user .avatar {
            background: var(--color-primary);
            color: white;
        }
        
        .message.assistant .avatar {
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
        }
        
        .message-content {
            flex: 1;
            background: var(--color-surface);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--color-border);
        }
        
        .message.user .message-content {
            background: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }
        
        .message.system {
            background: #f0f9ff;
            border-left: 3px solid var(--color-primary);
        }
        
        /* Typing indicator */
        .typing-indicator {
            display: none;
            padding: 1rem;
        }
        
        .typing-indicator.active {
            display: block;
        }
        
        .typing-bubble {
            display: flex;
            gap: 0.75rem;
            align-items: flex-start;
        }
        
        .typing-bubble .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--color-bg);
            color: var(--color-text);
            border: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .typing-dots {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 0.5rem;
            padding: 0.75rem;
            display: flex;
            gap: 0.25rem;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--color-text);
            opacity: 0.4;
            animation: typing 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        
        /* Artifact Reference (clickable section links) */
        .artifact-reference {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            cursor: pointer !important;
            transition: all 0.2s ease;
            max-width: fit-content;
            margin: 0.5rem 0;
            user-select: none;
        }

        .artifact-reference:hover {
            background: #e0f2fe;
            border-color: var(--color-primary);
            transform: translateX(2px);
        }

        .artifact-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .artifact-info {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }

        .artifact-title {
            font-weight: 500;
            color: var(--color-text);
            font-size: 0.875rem;
        }

        .artifact-type {
            font-size: 0.75rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
    </style>
    
    <!-- Load the FIXED component with updateQuickActions() -->
    <script src="input-group-component.js?v=fixed"></script>
    
    <!-- Load marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Load AI configuration and label generation -->
    <script>
        // Configuration
        const CONFIG = {
            WORKER_URL: 'https://tech-writer-ai-proxy.julian-harris.workers.dev',
            MODEL: 'gemini-2.0-flash',
            MAX_TOKENS: 1024,
            TEMPERATURE: 0.0
        };

        // Tone profile for tech writer assistant
        const TONE_PROFILE = `TONE OF VOICE PROFILE

Skeptical Optimism (Core Dimension):
Description: A foundational tone that approaches claims with healthy skepticism but maintains an underlying optimism about the potential of Vibe Coding and AI agents. It questions hype while looking for genuine value and practical applications.
Application: Critically evaluate tools and success stories, acknowledge limitations and potential pitfalls, but ultimately highlight the empowering aspects and future possibilities in a positive light.

Upbeat & Engaging:
Description: The overall energy should be positive, enthusiastic, and engaging, drawing the reader in rather than presenting information dryly.
Application: Use active voice, varied sentence structure, and a generally positive framing, even when discussing complex or challenging topics.

Truthful & Accurate (Evidence-Based):
Description: All information, especially claims and technical descriptions, must be grounded in verifiable facts and evidence. Avoid making unsubstantiated statements.
Application: Prioritize accuracy in describing tools, technologies, and case studies. Clearly distinguish between established facts, reported claims (with sources), and speculative future trends.

Slightly Sarcastic / Witty Humor:
Description: Incorporate occasional, subtle sarcasm or witty observations to add personality and make the content more relatable and entertaining.
Application: Use sparingly in appropriate contexts, perhaps when commenting on industry hype, common misconceptions, or the quirks of technology.

Clear & Accessible (Non-Technical Focus):
Description: While knowledgeable, the language must remain accessible to non-technical people with business ideas.
Application: Break down complex concepts into simpler terms. Use analogies or relatable examples.

Conversational & Relatable:
Description: Avoid overly academic or formal language. The tone should feel more like an engaging conversation with a knowledgeable guide.
Application: Use contractions where appropriate. Address the reader directly.`;

        // Build tool definitions for navigation
        function buildToolDefinitions(sections) {
            if (!sections || sections.length === 0) {
                return [];
            }
            
            // Build structured hierarchy
            const sectionStructure = sections.map(s => ({
                name: s.title,
                subsections: s.subsections.map(sub => sub.title)
            }));
            
            // Generate clear description
            const sectionDescriptions = sectionStructure.map(s => {
                if (s.subsections.length > 0) {
                    return `${s.name} (subsections: ${s.subsections.join(', ')})`;
                }
                return s.name;
            }).join('; ');
            
            const sectionNames = sectionStructure.map(s => s.name);
            const allSubsections = sectionStructure.flatMap(s => s.subsections);
            const uniqueSubsections = [...new Set(allSubsections)];
            
            return [{
                function_declarations: [{
                    name: "navigate_to_section",
                    description: `When user asks about content related to these sections, navigate there instead of describing it. Available sections: ${sectionDescriptions}`,
                    parameters: {
                        type: "object",
                        properties: {
                            section: {
                                type: "string",
                                description: "The main section name",
                                enum: sectionNames
                            },
                            subsection: {
                                type: "string",
                                description: "The subsection name within the main section (optional)",
                                enum: uniqueSubsections.length > 0 ? uniqueSubsections : undefined
                            }
                        },
                        required: ["section"]
                    }
                }]
            }];
        }

        // Parse assistant response for tool calls
        function parseAssistantResponse(responseData) {
            if (!responseData.candidates || !responseData.candidates[0] || !responseData.candidates[0].content) {
                throw new Error('Invalid response format from AI model');
            }
            
            const content = responseData.candidates[0].content;
            
            // Check for function call
            if (content.parts && content.parts[0] && content.parts[0].functionCall) {
                const functionCall = content.parts[0].functionCall;
                return {
                    toolCall: {
                        tool: functionCall.name,
                        section: functionCall.args.section,
                        subsection: functionCall.args.subsection
                    },
                    text: ""
                };
            }
            
            // Regular text response
            if (content.parts && content.parts[0] && content.parts[0].text) {
                return { text: content.parts[0].text };
            }
            
            throw new Error('No valid content in response');
        }

        // Handle tool calls for navigation (FIXED to match working version)
        function handleToolCall(toolCall, sections, app) {
            console.log('Handling tool call:', toolCall);
            
            if (toolCall.tool === 'navigate_to_section') {
                const { section: sectionName, subsection: subsectionName } = toolCall;
                console.log(`Looking for section: "${sectionName}", subsection: "${subsectionName}"`);
                
                // Find matching section by name (case-insensitive)
                const sectionObj = sections.find(
                    s => s.title.toLowerCase() === sectionName.toLowerCase()
                );
                
                if (!sectionObj) {
                    console.error('Section not found:', sectionName);
                    app.addMessage(`I couldn't find the section "${sectionName}". Please check the section name and try again.`, 'assistant');
                    return;
                }
                
                if (subsectionName) {
                    // User wants to navigate to a subsection
                    const subsectionObj = sectionObj.subsections.find(
                        sub => sub.title.toLowerCase() === subsectionName.toLowerCase()
                    );
                    
                    if (subsectionObj) {
                        console.log('Navigating to subsection:', subsectionObj.id, 'in section:', sectionObj.id);
                        app.scrollToElement(subsectionObj.id);
                        app.addArtifactToChat(`${sectionObj.title} > ${subsectionObj.title}`, 'subsection', subsectionObj.id);
                        
                        // Open document viewer on mobile
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                            document.getElementById('overlay').classList.add('active');
                        }
                    } else {
                        // Subsection not found, fallback to main section
                        console.log('Subsection not found, falling back to main section');
                        app.scrollToElement(sectionObj.id);
                        app.addArtifactToChat(sectionObj.title, 'section', sectionObj.id);
                        app.addMessage(`I couldn't find the subsection "${subsectionName}" in ${sectionName}, so I'm showing the main section.`, 'assistant');
                        
                        // Open document viewer on mobile
                        if (window.innerWidth <= 768) {
                            document.getElementById('documentViewer').classList.add('open');
                            document.getElementById('overlay').classList.add('active');
                        }
                    }
                } else {
                    // Navigate to main section only
                    console.log('Navigating to main section:', sectionObj.id);
                    app.scrollToElement(sectionObj.id);
                    app.addArtifactToChat(sectionObj.title, 'section', sectionObj.id);
                    
                    // Open document viewer on mobile
                    if (window.innerWidth <= 768) {
                        document.getElementById('documentViewer').classList.add('open');
                        document.getElementById('overlay').classList.add('active');
                    }
                }
            }
        }

        // Quick Action Label Generation Prompt (from DSPy training)
        const QUICK_ACTION_PROMPT = `Generate short 1-3 word labels for section headings used as quick action buttons.

Examples:
Input: ["Tech Writer Agent in 7 different frameworks", "But first, how many agent maker frameworks are there?", "Why did you pick the tech writer agent for evaluation?"]
Output: ["Overview", "Agent Landscape", "Tech Writer Choice"]

Input: ["What did I learn?", "What did I standardise on?", "How did I rank them?"]
Output: ["Insights", "Shared Code", "Leaderboard"]

Guidelines:
- Keep labels concise (1-3 words maximum)
- Use title case for labels
- Return ONLY a JSON array of strings.

Input: {headings}
Output:`;

        // Generate quick action labels for an array of headings
        window.generateQuickActionLabels = async function generateQuickActionLabels(headings) {
            if (!headings || headings.length === 0) return [];
            
            const prompt = QUICK_ACTION_PROMPT.replace('{headings}', JSON.stringify(headings));
            
            try {
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: CONFIG.MODEL,
                        contents: [
                            { role: "user", parts: [{ text: prompt }] }
                        ],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 256
                        }
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API error');
                }
                
                let content = data.candidates[0].content.parts[0].text.trim();
                
                if (content.startsWith('```json')) {
                    content = content.replace(/^```json\s*\n?/, '').replace(/\n?```\s*$/, '');
                } else if (content.startsWith('```')) {
                    content = content.replace(/^```\s*\n?/, '').replace(/\n?```\s*$/, '');
                }
                
                const labels = JSON.parse(content);
                
                if (labels.length !== headings.length) {
                    throw new Error('Label count mismatch');
                }
                
                console.log('‚úÖ Successfully generated labels using AI:', labels);
                return labels;
            } catch (error) {
                console.error('‚ùå Failed to generate labels with AI:', error);
                console.warn('‚ö†Ô∏è USING FALLBACK: Simple word extraction');
                
                const fallbackLabels = headings.map(heading => {
                    const words = heading.split(' ').filter(w => 
                        w.length > 2 && !['the', 'and', 'for', 'with', 'from'].includes(w.toLowerCase())
                    );
                    return words.slice(0, 2).join(' ') || heading.slice(0, 20);
                });
                
                console.log('üìù Fallback labels:', fallbackLabels);
                return fallbackLabels;
            }
        }
    </script>
</head>
<body>
    <div class="app-layout">
        <!-- Mobile header -->
        <header class="mobile-header">
            <button onclick="app.toggleSidebar()" style="padding: 0.5rem; background: none; border: none; cursor: pointer;">‚ò∞</button>
            <h1 style="margin: 0 auto; font-size: 1.25rem;">Document Chat</h1>
        </header>
        
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <h2>Documentation</h2>
            <div id="sidebar-sections">
                <!-- Populated dynamically -->
            </div>
        </aside>
        
        <!-- Chat panel -->
        <section class="chat-panel">
            <div class="messages-area" id="messagesArea">
                <div class="message assistant">
                    <div class="avatar">AI</div>
                    <div class="message-content">Welcome! This is the FINAL WORKING version with complete chat integration. Both chat and quick actions should work perfectly with full conversation history.</div>
                </div>
            </div>
            
            <!-- Typing indicator -->
            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-bubble">
                    <div class="avatar">AI</div>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            </div>
            
            <!-- FIXED input group component that uses updateQuickActions() -->
            <input-group id="mainInput"></input-group>
        </section>
        
        <!-- Document viewer -->
        <section class="document-viewer" id="documentViewer">
            <div id="documentContent">
                <!-- Populated dynamically -->
            </div>
        </section>
    </div>
    
    <!-- Mobile overlay -->
    <div class="overlay" id="overlay" onclick="app.closeAll()"></div>
    
    <script type="module">
        import { documentParser } from './src/components/document-parser.js';
        
        // Complete state management (from working script.js)
        const state = {
            currentSection: null,
            currentSubsection: null,
            chatHistory: [],
            documentContent: null,
            conversationHistory: [],
            isProcessing: false
        };

        // Application state and methods
        const app = {
            sections: [],
            currentSection: null,
            mainInput: null,
            
            init() {
                console.log('üéØ FINAL VERSION - App init starting...');
                this.mainInput = document.getElementById('mainInput');
                console.log('Found mainInput element:', this.mainInput);
                
                if (!this.mainInput) {
                    console.error('CRITICAL: mainInput element not found!');
                    return;
                }
                
                // Verify the component has the fixed methods
                if (typeof this.mainInput.updateQuickActions === 'function') {
                    console.log('‚úÖ Component has updateQuickActions method - GOOD!');
                } else {
                    console.error('‚ùå Component missing updateQuickActions method - OLD VERSION!');
                }
                
                this.setupEventListeners();
                this.loadDocument().catch(async (err) => {
                    console.error('Document load failed:', err);
                    this.addMessage('System', `Error loading document: ${err.message}`, true);
                    await this.loadSampleDocument();
                });
            },
            
            setupEventListeners() {
                console.log('üì° Setting up event listeners...');
                
                if (!this.mainInput) {
                    console.error('mainInput not found!');
                    return;
                }
                
                // Quick action clicks
                this.mainInput.addEventListener('action-click', (e) => {
                    console.log('üîò Quick action clicked:', e.detail.actionId);
                    this.navigateToSubsection(e.detail.actionId);
                });
                
                // Message submissions
                this.mainInput.addEventListener('message-submit', (e) => {
                    console.log('‚úÖ Message submit event received:', e.detail.message);
                    this.sendMessage(e.detail.message);
                });
            },
            
            async loadDocument() {
                console.log('üìÑ loadDocument starting...');
                try {
                    const response = await fetch('report.md');
                    if (!response.ok) {
                        throw new Error('Failed to load report.md');
                    }
                    const markdown = await response.text();
                    
                    // Store document content for system prompt (CRITICAL!)
                    state.documentContent = markdown;
                    
                    this.sections = await documentParser.parseMarkdown(markdown);
                    this.populateSidebar();
                    this.renderDocument();
                    
                    if (this.sections.length > 0) {
                        this.selectSection(this.sections[0].id);
                    }
                    
                    console.log('üìÑ Document loaded successfully');
                    
                } catch (error) {
                    console.error('‚ùå loadDocument error:', error);
                    throw error;
                }
            },
            
            populateSidebar() {
                const container = document.getElementById('sidebar-sections');
                container.innerHTML = '';
                
                this.sections.forEach(section => {
                    const div = document.createElement('div');
                    div.className = 'sidebar-item';
                    div.innerHTML = `
                        ${section.title}
                        ${section.bracketedPhrase ? `<span class="badge">${section.bracketedPhrase}</span>` : ''}
                    `;
                    div.onclick = () => this.selectSection(section.id);
                    container.appendChild(div);
                });
            },
            
            renderDocument() {
                const content = document.getElementById('documentContent');
                content.innerHTML = documentParser.renderFullHTML();
            },
            
            selectSection(sectionId) {
                console.log('üéØ selectSection called with:', sectionId);
                const section = this.sections.find(s => s.id === sectionId);
                if (!section) return;
                
                this.currentSection = sectionId;
                
                // Update sidebar active state
                const items = document.querySelectorAll('.sidebar-item');
                this.sections.forEach((s, index) => {
                    items[index]?.classList.toggle('active', s.id === sectionId);
                });
                
                // CRITICAL: Update quick actions using FIXED component
                console.log('üîÑ Setting quick actions using FIXED component...');
                console.log('Component updateQuickActions method exists?', typeof this.mainInput.updateQuickActions);
                
                this.mainInput.quickActions = section.subsections.map(sub => ({
                    id: sub.id,
                    text: sub.label || sub.title
                }));
                
                console.log('‚úÖ Quick actions set successfully without render()!');
                
                // Generate AI labels for quick actions if not already done
                if (section.subsections.length > 0 && !section.subsections[0].label && window.generateQuickActionLabels) {
                    this.generateLabelsForSection(section);
                }
                
                this.scrollToElement(sectionId);
                state.currentSection = sectionId;
            },
            
            // Generate AI labels for a section's subsections
            async generateLabelsForSection(section) {
                if (!section.subsections || section.subsections.length === 0) return;
                
                const headings = section.subsections.map(sub => sub.title);
                
                try {
                    const labels = await window.generateQuickActionLabels(headings);
                    
                    section.subsections.forEach((sub, index) => {
                        if (labels[index]) {
                            sub.label = labels[index];
                        }
                    });
                    
                    if (this.currentSection === section.id) {
                        console.log('üîÑ Updating quick actions with AI labels using FIXED component...');
                        this.mainInput.quickActions = section.subsections.map(sub => ({
                            id: sub.id,
                            text: sub.label || sub.title
                        }));
                        console.log('‚úÖ Quick actions updated with AI labels successfully!');
                    }
                } catch (error) {
                    console.error('Failed to generate labels for section:', section.title, error);
                }
            },
            
            navigateToSection(sectionId, subsectionId) {
                console.log('üîó Navigating to section:', sectionId, 'subsection:', subsectionId);
                
                // Find and select the section
                const section = this.sections.find(s => s.id === sectionId);
                if (section) {
                    this.selectSection(sectionId);
                }
                
                // If subsection specified, scroll to it
                if (subsectionId) {
                    setTimeout(() => {
                        this.scrollToElement(subsectionId);
                    }, 100);
                } else {
                    this.scrollToElement(sectionId);
                }
                
                // Open document viewer on mobile
                if (window.innerWidth <= 768) {
                    document.getElementById('documentViewer').classList.add('open');
                    document.getElementById('overlay').classList.add('active');
                }
            },

            navigateToSubsection(subsectionId) {
                console.log('üîó Navigating to subsection:', subsectionId);
                this.scrollToElement(subsectionId);
                
                if (window.innerWidth <= 768) {
                    document.getElementById('documentViewer').classList.add('open');
                    document.getElementById('overlay').classList.add('active');
                }
            },
            
            scrollToElement(elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                    element.style.background = '#e0f2fe';
                    element.style.transition = 'background 0.3s ease';
                    setTimeout(() => {
                        element.style.background = '';
                    }, 1000);
                }
            },
            
            // Complete sendMessage function from working script.js
            async sendMessage(message) {
                if (!message || state.isProcessing) return;
                
                state.isProcessing = true;
                
                // Add user message
                this.addMessage(message, 'user');
                
                // Show typing indicator
                this.showTyping();
                
                // Process message with LLM
                try {
                    const response = await this.processUserMessage(message);
                    this.hideTyping();
                    
                    // Check if response contains tool calls
                    if (response.toolCall) {
                        // Use FIXED handleToolCall that adds artifacts like working version
                        handleToolCall(response.toolCall, this.sections, this);
                        
                        // Update conversation history with tool call
                        state.conversationHistory.push(
                            { role: 'user', content: message }
                        );
                        
                        state.conversationHistory.push({
                            role: 'assistant',
                            content: '',
                            parts: [{
                                functionCall: {
                                    name: response.toolCall.tool,
                                    args: {
                                        section: response.toolCall.section,
                                        subsection: response.toolCall.subsection || ''
                                    }
                                }
                            }]
                        });
                        
                        // Add function response to history  
                        state.conversationHistory.push({
                            role: 'function',
                            parts: [{
                                functionResponse: {
                                    name: response.toolCall.tool,
                                    response: { result: "Navigation completed" }
                                }
                            }]
                        });
                        
                    } else {
                        this.addMessage(response.text, 'assistant');
                        
                        // Update conversation history
                        state.conversationHistory.push(
                            { role: 'user', content: message },
                            { role: 'assistant', content: response.text }
                        );
                    }
                } catch (error) {
                    console.error('‚ùå Chat error:', error);
                    this.hideTyping();
                    this.addMessage(`I apologize, but I encountered an error: ${error.message}`, 'assistant');
                }
                
                state.isProcessing = false;
            },

            // Process user message with complete tool handling
            async processUserMessage(message) {
                const contents = this.buildContents(message);
                const tools = buildToolDefinitions(this.sections);
                
                const requestBody = {
                    model: CONFIG.MODEL,
                    contents: contents,
                    generationConfig: {
                        temperature: 0.7,
                        maxOutputTokens: 512
                    }
                };
                
                // Add tools if available
                if (tools.length > 0) {
                    requestBody.tools = tools;
                }
                
                console.log('üîß Making API call with tools:', tools.length > 0 ? 'enabled' : 'disabled');
                
                const response = await fetch(CONFIG.WORKER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API error');
                }
                
                // Parse response for tool calls or text
                return parseAssistantResponse(data);
            },

            // Build contents with conversation history
            buildContents(currentMessage) {
                const contents = [];
                
                // Build system prompt
                const systemPrompt = this.buildSystemPrompt();
                
                // Always include system prompt at the beginning
                contents.push({
                    role: "user",
                    parts: [{ text: systemPrompt }]
                });
                contents.push({
                    role: "model", 
                    parts: [{ text: "I understand. I'm ready to help you navigate and understand this document. I can answer questions about its content and help you find specific sections." }]
                });
                
                // Add conversation history
                state.conversationHistory.forEach(msg => {
                    if (msg.role === 'function') {
                        // Function responses use the exact format from history
                        contents.push({
                            role: 'function',
                            parts: msg.parts
                        });
                    } else if (msg.parts) {
                        // Tool calls with parts array
                        contents.push({
                            role: msg.role === 'assistant' ? 'model' : msg.role,
                            parts: msg.parts
                        });
                    } else {
                        // Regular text messages
                        contents.push({
                            role: msg.role === 'user' ? 'user' : 'model',
                            parts: [{ text: msg.content }]
                        });
                    }
                });
                
                // Add current message
                contents.push({
                    role: "user",
                    parts: [{ text: currentMessage }]
                });
                
                return contents;
            },

            buildSystemPrompt() {
                let prompt = `You are a helpful AI assistant that helps users navigate and understand the report.
    You respond in a tone of voice profile as defined below. Your answers should be accurate, concise, and helpful.

<report>
${state.documentContent || 'No document loaded yet.'}
</report>

<available-sections>
`;
                
                // Add available sections for navigation (from working script.js)
                if (this.sections) {
                    this.sections.forEach(section => {
                        prompt += `- ${section.title} (id: ${section.id})`;
                        if (section.subsections.length > 0) {
                            prompt += '\n  Subsections:';
                            section.subsections.forEach(sub => {
                                prompt += `\n    - ${sub.title} (id: ${sub.id})`;
                            });
                        }
                        prompt += '\n';
                    });
                }
                
                prompt += `</available-sections>

<tone-profile>
${TONE_PROFILE}
</tone-profile>

Remember: 
- Base your answers on the document content provided above
- Be helpful in navigating the document
- Keep responses concise and relevant
- When users ask about specific topics that are covered in the sections, jump to that section instead of responding with a message`;
                
                return prompt;
            },
            
            buildDocumentContext() {
                if (!this.sections || this.sections.length === 0) {
                    return "No document loaded.";
                }
                
                let context = "Document sections:\\n";
                this.sections.forEach(section => {
                    context += `- ${section.title}`;
                    if (section.subsections.length > 0) {
                        context += ` (${section.subsections.map(sub => sub.title).join(', ')})`;
                    }
                    context += "\\n";
                });
                
                if (this.currentSection) {
                    const section = this.sections.find(s => s.id === this.currentSection);
                    if (section) {
                        context += `\\nCurrently viewing: ${section.title}`;
                    }
                }
                
                return context;
            },
            
            
            showTyping() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.classList.add('active');
                    this.scrollToBottom();
                }
            },
            
            hideTyping() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.classList.remove('active');
                }
            },

            scrollToBottom() {
                const messagesArea = document.getElementById('messagesArea');
                if (messagesArea) {
                    messagesArea.scrollTop = messagesArea.scrollHeight;
                }
            },

            // Add clickable artifact reference (from working script.js)
            addArtifactToChat(title, type, sectionId) {
                const messagesArea = document.getElementById('messagesArea');
                const artifactDiv = document.createElement('div');
                artifactDiv.className = 'artifact-reference';
                artifactDiv.innerHTML = `
                    <div class="artifact-icon">${type === 'section' ? 'üìë' : 'üìÑ'}</div>
                    <div class="artifact-info">
                        <div class="artifact-title">${title}</div>
                        <div class="artifact-type">${type === 'section' ? 'Section' : 'Subsection'}</div>
                    </div>
                `;
                
                artifactDiv.addEventListener('click', () => {
                    if (type === 'section') {
                        this.navigateToSection(sectionId);
                    } else {
                        // For subsections, find parent section
                        const section = this.sections.find(s => 
                            s.subsections.some(sub => sub.id === sectionId)
                        );
                        if (section) {
                            this.navigateToSection(section.id, sectionId);
                        }
                    }
                });
                
                messagesArea.appendChild(artifactDiv);
                this.scrollToBottom();
            },
            
            addMessage(content, sender) {
                const messagesArea = document.getElementById('messagesArea');
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}`;
                
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.textContent = sender === 'user' ? 'You' : 'AI';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                if (sender === 'assistant') {
                    // Parse markdown in assistant messages
                    contentDiv.innerHTML = marked.parse(content);
                } else {
                    contentDiv.textContent = content;
                }
                
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);
                
                // Remove welcome message if exists
                const welcomeMsg = messagesArea.querySelector('.message:first-child');
                if (welcomeMsg && welcomeMsg.querySelector('.message-content')?.textContent.includes('Welcome!')) {
                    welcomeMsg.remove();
                }
                
                messagesArea.appendChild(messageDiv);
                this.scrollToBottom();
            },
            
            async loadSampleDocument() {
                const fallbackMarkdown = `# Tech Writer Agent Demo [Fallback]

Couldn't load report.md - using sample content.

## Sample Section

This is a demonstration of the document parser.

## Another Section

Quick actions will be generated from these H2 headings.`;
                
                // Store document content for system prompt (CRITICAL!)
                state.documentContent = fallbackMarkdown;
                
                this.sections = await documentParser.parseMarkdown(fallbackMarkdown);
                this.populateSidebar();
                this.renderDocument();
                if (this.sections.length > 0) {
                    this.selectSection(this.sections[0].id);
                }
            },
            
            // Mobile functions
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('overlay');
                sidebar.classList.toggle('open');
                overlay.classList.toggle('active');
            },
            
            closeAll() {
                document.getElementById('sidebar').classList.remove('open');
                document.getElementById('documentViewer').classList.remove('open');
                document.getElementById('overlay').classList.remove('active');
            }
        };
        
        // Make app methods available globally for onclick handlers
        window.app = app;
        
        // Global error handlers
        window.addEventListener('error', (e) => {
            console.error('üí• Global error:', e.error, e.message, e.filename, e.lineno);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('üí• Unhandled promise rejection:', e.reason);
        });
        
        // Global form prevention
        document.addEventListener('submit', (e) => {
            console.log('üõë Form submit prevented');
            e.preventDefault();
            e.stopPropagation();
            return false;
        });
        
        // Page refresh detection
        window.addEventListener('beforeunload', (e) => {
            console.warn('üö® Page refresh detected!');
        });
        
        // Initialize when ready
        customElements.whenDefined('input-group').then(() => {
            console.log('‚úÖ input-group component is ready');
            app.init();
        });
    </script>
</body>
</html>